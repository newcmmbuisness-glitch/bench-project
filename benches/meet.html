<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>One To Meet</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
	<script src="https://www.paypal.com/sdk/js?client-id=Adk-v-jGvp2KRbnoJkSvcKNsPqhdlj4tC_pEWtpBMhZrgbOw7h_MeV94UbYvwspxFidq2mpcAYxbedT5&currency=EUR"></script>
    <style>
		body { 
			margin: 0; 
			font-family: 'Inter', Arial, sans-serif;   /* wieder deine Hauptschrift */
			background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%); /* schwarz-grau Hintergrund */
			color: #000;
			min-height: 100vh;
		}

		/* leichter Silber-Schimmer-Effekt für Überschriften */
		.shimmer {
			background: linear-gradient(90deg, #aaa, #ddd, #aaa);
			background-size: 200% 100%;
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			animation: shimmer 6s infinite linear;
			font-weight: normal; /* nicht fett */
		}

		@keyframes shimmer {
			0% { background-position: -200% 0; }
			100% { background-position: 200% 0; }
		}

		/* Weißer Button */
		.white-btn {
			background: #fff;
			color: #000;
			border: none;
			padding: 12px 30px;
			font-family: 'Courier New', monospace;
			font-size: 1.1rem;
			border-radius: 25px;
			cursor: pointer;
			transition: all 0.3s ease;
		}
		.white-btn:hover {
			background: #ddd;
			transform: scale(1.05);
		}

        /* Sidebar Styling - übernommen von index.html */
        .sidebar {
            position: fixed;
            top: 0;
            left: -250px;
            width: 250px;
            height: 100%;
            background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
            box-shadow: 2px 0 15px rgba(0,0,0,0.1);
            z-index: 1500;
            transition: left 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .sidebar.open { left: 0; }

        .sidebar-header {
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            border-bottom: 1px solid #e0e0e0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            color: white;
        }

        .sidebar-footer {
            padding: 15px 20px;
            border-top: 1px solid #e0e0e0;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        .sidebar-logo {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: white;
            padding: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .sidebar-logo:hover { transform: scale(1.05); }

        .sidebar-title {
            font-size: 20px;
            font-weight: 600;
        }

        .sidebar-content {
            flex: 1;
            padding: 20px 0;
        }

        .sidebar-item {
            display: flex;
            align-items: center;
            padding: 15px 25px;
            text-decoration: none;
            color: #333;
            transition: all 0.3s ease;
            border-bottom: 1px solid #f0f0f0;
            position: relative;
        }

        .sidebar-item:hover {
            background: linear-gradient(90deg, rgba(76,175,80,0.1) 0%, transparent 100%);
            color: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            transform: translateX(5px);
        }

        .sidebar-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            transition: width 0.3s ease;
        }

        .sidebar-item:hover::before { width: 4px; }

        .sidebar-icon {
            margin-right: 15px;
            font-size: 20px;
            width: 24px;
            text-align: center;
        }

        .main-logo {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1600;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: rgba(255,255,255,0.9);
            box-shadow: 0 2px 15px rgba(0,0,0,0.15);
            padding: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .main-logo.sidebar-open {
            opacity: 0;
            pointer-events: none;
        }

        .main-logo img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: contain;
        }

        .sidebar-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.3);
            z-index: 1400;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .sidebar-overlay.active {
            display: block;
            opacity: 1;
        }

		/* New Button Styling */
		/* Floating Buttons - Updated CSS */
		.floating-button {
		    position: fixed;
		    bottom: 2rem;
		    width: 4rem;
		    height: 4rem;
		    border-radius: 50%;
		    display: flex;
		    align-items: center;
		    justify-content: center;
		    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
		    transition: transform 0.2s, opacity 0.3s;
		    cursor: pointer;
		    z-index: 1000;
		    opacity: 1;
		    visibility: visible;
		}
		
		.floating-button:hover {
		    transform: scale(1.05);
		}
		
		.floating-button.hidden {
		    opacity: 0;
		    visibility: hidden;
		    pointer-events: none;
		}
		
		.profile-button {
		    left: 2rem;
		    background-color: #ff5e5e;
		    color: white;
		}
		
		.chat-button {
		    right: 2rem;
		    background-color: #007bff;
		    color: white;
		}

		/* Profil Popup - Dunkleres Design */
		.profile-popup {
			background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 20px;
			padding: 30px;
			max-width: 500px;
			width: 90%;
			max-height: 90vh;
			overflow-y: auto;
			box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			z-index: 1001;
			backdrop-filter: blur(20px);
			color: #ffffff;
		}
		
		/* Modal Overlay Update */
		#modalOverlay {
			background: rgba(0, 0, 0, 0.8);
			backdrop-filter: blur(10px);
		}

		/* Profil Image Styling */
		#popupProfileImage {
			width: 140px !important;
			height: 140px !important;
			border-radius: 50%;
			object-fit: cover;
			border: 3px solid rgba(255, 255, 255, 0.2);
			margin-bottom: 20px;
			box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
		}

		/* Profil Name mit Shimmer */
		#popupProfileName {
			font-size: 1.8rem;
			font-weight: 600;
			margin-bottom: 8px;
		}

		/* Distance & Details */
		#popupProfileDistance {
			color: #b0b0b0 !important;
			font-size: 0.9rem;
			margin-bottom: 15px;
			background: rgba(255, 255, 255, 0.05);
			padding: 6px 12px;
			border-radius: 12px;
		}

		/* Gender Display */
		.profile-gender {
			color: #b0b0b0;
			font-size: 0.9rem;
			margin-bottom: 10px;
			display: inline-block;
			background: rgba(255, 255, 255, 0.08);
			padding: 4px 10px;
			border-radius: 8px;
		}

		/* Postal Code */
		.profile-postal {
			color: #b0b0b0;
			font-size: 0.85rem;
			margin-bottom: 15px;
		}

		/* Description Styling */
		#popupProfileDescription {
			color: #e0e0e0 !important;
			font-size: 1rem;
			line-height: 1.6;
			margin-bottom: 20px;
			max-width: 400px;
		}

		/* Interests Container */
		#popupProfileInterests {
			margin-bottom: 25px;
		}

		#popupProfileInterests span {
			background: rgba(255, 255, 255, 0.1) !important;
			color: #ffffff !important;
			border: 1px solid rgba(255, 255, 255, 0.2);
			padding: 8px 14px;
			border-radius: 20px;
			font-size: 0.9rem;
			margin: 4px;
			display: inline-block;
			transition: all 0.3s ease;
		}

		#popupProfileInterests span:hover {
			background: rgba(255, 255, 255, 0.15) !important;
			transform: translateY(-2px);
		}

		/* Prompts & Answers Section */
		.profile-qa-section {
			width: 100%;
			margin: 20px 0;
			text-align: left;
		}

		.profile-qa-item {
			background: rgba(255, 255, 255, 0.05);
		}

        /* Auth buttons - übernommen */
        .auth-buttons {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            display: flex;
            gap: 10px;
        }

        .login-btn, .logout-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .logout-btn { background: #f44336; }

        /* Modal styles - übernommen */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: none;
            border-radius: 10px;
            width: 90%;
            max-width: 400px;
            position: relative;
        }

        .close {
            position: absolute;
            right: 15px;
            top: 10px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover { color: black; }

        .auth-tabs {
            display: flex;
            margin-bottom: 20px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: #f1f1f1;
            cursor: pointer;
        }

        .tab-btn.active { background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%); }

        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .tab-content form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .tab-content input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .tab-content button {
            padding: 12px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
		
        .captcha-box {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .captcha-box p { margin: 5px 0; font-weight: bold; }
        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            z-index: 2001;
            display: none;
        }
		

        /* Notification */
        .notification {
            position: fixed;
            top: 120px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 25px;
            z-index: 2001;
            display: none;
            backdrop-filter: blur(10px);
        }
        .notification.success { background: rgba(212, 237, 218, 0.9); color: #155724; border: 1px solid #c3e6cb; }
        .notification.error { background: rgba(248, 215, 218, 0.9); color: #721c24; border: 1px solid #f5c6cb; }

        /* Main App Container */
        .app-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 120px 20px 20px;
        }

        .welcome-screen {
            text-align: center;
            color: white;
            max-width: 400px;
        }

        .welcome-screen h1 {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 1rem;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .welcome-screen p {
            font-size: 1.1rem;
            margin-bottom: 2rem;
            opacity: 0.9;
        }
		
		#welcomeScreen {
			font-family: 'Courier New', monospace; 
			color: #e0e0e0;
			padding-top: 0 !important;
			margin-top: 0 !important;
		}
		

		#welcomeScreen .shimmer {
			background: linear-gradient(90deg, #aaa, #ddd, #aaa);
			background-size: 200% 100%;
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			animation: shimmer 6s infinite linear;
			font-weight: normal;
		}
			
		#welcomeScreen .white-btn {
			background: #fff;
			color: #000;
			border: none;
			padding: 12px 30px;
			font-family: 'Courier New', monospace;
			font-size: 1.1rem;
			border-radius: 25px;
			cursor: pointer;
			transition: all 0.3s ease;
		}
		#welcomeScreen .white-btn:hover {
			background: #ddd;
			transform: scale(1.05);
		}

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            margin-top: 30px;
        }

        .action-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .btn-primary {
            background: #ffffff;
            color: #000000;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2);
        }

        .btn-primary:hover {
            background: #f0f0f0;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 255, 255, 0.3);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255,255,255,0.1);
        }

        /* Error Styling */
        .error {
            color: #ff6b6b;
            font-size: 14px;
            margin-top: 5px;
            display: none;
        }

		.swipe-container {
			position: relative;
			width: 100%;
			max-width: 350px;
			height: auto;
			margin: 20px auto;
			min-height: 600px;
			/* Neue Anpassungen für Zentrierung */
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			text-align: center; /* Sicherstellen, dass Text in der Mitte ist */
		}

		.card-stack {
		    position: relative;
		    width: 100%;
		    height: 500px;
		    margin-bottom: 20px;
		}

		.swipe-card {
			position: absolute;
			width: 100%;
			height: 100%; /* Wichtig: Macht die Karte flexibel, um den Inhalt anzupassen */
			background: white;
			border-radius: 15px;
			box-shadow: 0 8px 25px rgba(0,0,0,0.15);
			cursor: grab;
			transition: transform 0.3s ease, opacity 0.3s ease;
			overflow: hidden;
			user-select: none;
			display: flex; /* Neu: Verwenden Sie Flexbox, um den Inhalt zu handhaben */
			flex-direction: column;
		}

		.swipe-card.dragging {
		    pointer-events: none;
		    user-select: none;
		}

        .swipe-card.swiped-left {
            transform: translateX(-100%) rotate(-30deg);
            opacity: 0;
        }

        .swipe-card.swiped-right {
            transform: translateX(100%) rotate(30deg);
            opacity: 0;
        }
		.card-image {
			width: 100%;
			height: 100%; /* Der entscheidende Punkt: Bild füllt die gesamte Höhe */
			object-fit: cover;
			position: absolute; /* Neu: Absolute Position, um das Bild als Hintergrund zu verwenden */
			top: 0;
			left: 0;
			z-index: 1; /* Neu: Stellt sicher, dass das Bild hinter dem Inhalt liegt */
		}

		.card-content {
			position: relative; /* Neu: Setzen Sie die Position auf relativ, um z-index zu aktivieren */
			z-index: 2; /* Neu: Stellt sicher, dass der Inhalt über dem Bild liegt */
			flex-grow: 1; /* Neu: Lässt den Inhalt den verbleibenden Platz ausfüllen */
			display: flex;
			flex-direction: column;
			justify-content: flex-end; /* Schiebt den Inhalt an den unteren Rand */
			background: linear-gradient(transparent, rgba(0,0,0,0.7));
			color: white;
			padding: 20px;
		}

		.card-header {
			display: flex;
			justify-content: space-between;
			align-items: flex-start;
			margin-bottom: 8px;
		}

		.card-name {
			font-size: 1.5rem;
			font-weight: 700;
			margin: 0;
			text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
			display: inline;
		}
		
		.card-age {
		    font-size: 1.5rem; /* Gleiche Schriftgröße wie Name */
		    font-weight: 400; /* Weniger fett als der Name */
		    text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
		    margin-left: 5px; /* Kleiner Abstand zum Namen */
		    display: inline; /* Stellt sicher, dass das Alter direkt neben dem Namen angezeigt wird */
		}

		.card-distance {
			font-size: 0.9rem;
			opacity: 0.9;
			background: rgba(255,255,255,0.15);
			padding: 4px 8px;
			border-radius: 12px;
			backdrop-filter: blur(10px);
			border: 1px solid rgba(255,255,255,0.1);
			white-space: nowrap;
			margin-left: 10px;
		}

		.card-description {
			font-size: 0.9rem;
			line-height: 1.4;
			opacity: 0.95;
			margin: 8px 0;
			display: -webkit-box;
			-webkit-line-clamp: 2;
			-webkit-box-orient: vertical;
			overflow: hidden;
			text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
		}

		.card-preferences {
			display: flex;
			align-items: center;
			gap: 6px;
			margin-top: 12px;
		}

		.preference-icon {
			font-size: 1.2rem;
			background: rgba(255,255,255,0.15);
			padding: 4px 6px;
			border-radius: 8px;
			backdrop-filter: blur(5px);
			border: 1px solid rgba(255,255,255,0.1);
		}

		.more-interests {
			font-size: 0.8rem;
			background: rgba(255,255,255,0.2);
			padding: 4px 8px;
			border-radius: 12px;
			opacity: 0.8;
			font-weight: 500;
		}

		/* Form enhancement for age field */
		.form-group label {
			display: block;
			margin-bottom: 5px;
			font-weight: 600;
			color: #333;
		}

		.form-group input[type="number"] {
			width: 100%;
			padding: 12px;
			border: 2px solid #e0e0e0;
			border-radius: 8px;
			font-size: 1rem;
			transition: border-color 0.3s ease;
		}

		.form-group input[type="number"]:focus {
			outline: none;
			border-color: #4CAF50;
		}

		.swipe-actions {
			display: flex; /* !important entfernen */
			justify-content: center;
			gap: 40px;
			margin-top: 20px;
			position: relative;
			z-index: 100;
		}
	
		.swipe-btn {
			width: 60px;
			height: 60px;
			border-radius: 50%;
			border: none;
			cursor: pointer;
			font-size: 1.5rem;
			transition: all 0.3s ease;
			box-shadow: 0 4px 15px rgba(0,0,0,0.1);
			position: relative;
			z-index: 101;
		}
		
		.swipe-btn.dislike {
			background: linear-gradient(135deg, #ff6b6b, #ee5a52);
			color: white;
			visibility: hidden;
		}
		
		.swipe-btn.like {
			background: linear-gradient(135deg, #4caf50, #45a049);
			color: white;
			visibility: hidden;
		}
		
		.swipe-btn:hover {
			transform: scale(1.1);
			box-shadow: 0 6px 20px rgba(0,0,0,0.2);
		}
		
		.swipe-btn:active {
			transform: scale(0.95);
		}

        /* Profile Creation */
		.profile-creation {
			background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 20px;
			padding: 30px;
			max-width: 600px;
			width: 90%;
			max-height: 90vh;
			overflow-y: auto;
			box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
			backdrop-filter: blur(20px);
			color: #ffffff;
		}

		.profile-creation h2 {
			background: linear-gradient(90deg, #aaa, #ddd, #aaa);
			background-size: 200% 100%;
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			animation: shimmer 6s infinite linear;
			font-weight: 600;
			text-align: center;
			font-size: 2rem;
			margin-bottom: 30px;
		}

        .form-group {
            margin-bottom: 20px;
        }

		.form-group label {
			display: block;
			margin-bottom: 8px;
			font-weight: 600;
			color: #e0e0e0;
			font-size: 0.95rem;
		}

		.form-group input, 
		.form-group textarea {
			width: 100%;
			padding: 15px;
			border: 1px solid rgba(255, 255, 255, 0.2);
			border-radius: 12px;
			font-size: 1rem;
			box-sizing: border-box;
			transition: all 0.3s ease;
			background: rgba(255, 255, 255, 0.05);
			color: #ffffff;
			backdrop-filter: blur(10px);
		}

		.form-group input:focus, 
		.form-group textarea:focus {
			outline: none;
			border-color: rgba(102, 126, 234, 0.6);
			background: rgba(255, 255, 255, 0.08);
			box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
		}

		.form-group input::placeholder,
		.form-group textarea::placeholder {
			color: rgba(255, 255, 255, 0.5);
		}
		
		.modern-file-upload { position: relative; width: 100%; }

		.file-upload-btn {
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			border: none;
			padding: 15px 25px;
			border-radius: 12px;
			color: white;
			font-weight: 600;
			cursor: pointer;
			width: 100%;
			text-align: center;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 10px;
			backdrop-filter: blur(10px);
			box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
		}

		.file-upload-btn:hover {
			background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
			transform: translateY(-2px);
			box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
		}

		.file-upload-btn.has-file {
			background: linear-gradient(135deg, #4caf50, #45a049);
		}

		.form-group select {
			width: 100%;
			padding: 15px;
			border: 1px solid rgba(255, 255, 255, 0.2);
			border-radius: 12px;
			font-size: 1rem;
			background: rgba(255, 255, 255, 0.05);
			color: #ffffff;
			backdrop-filter: blur(10px);
			cursor: pointer;
			transition: all 0.3s ease;
			appearance: none;
			background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
			background-repeat: no-repeat;
			background-position: right 15px center;
			background-size: 16px;
		}

		.form-group select:focus {
			outline: none;
			border-color: rgba(102, 126, 234, 0.6);
			background: rgba(255, 255, 255, 0.08);
			box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
		}

		.form-group select option {
			background: #2a2a2a;
			color: #ffffff;
			padding: 10px;
		}		

        .preferences-section {
            margin: 20px 0;
        }

        .preferences-icons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .preference-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            border-radius: 12px;
            transition: all 0.3s ease;
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .preference-option:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }

        .preference-option.selected {
            background: rgba(102, 126, 234, 0.2);
            border-color: #667eea;
        }
        .preference-option span {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .preference-option.selected {
            background: rgba(102, 126, 234, 0.2);
            border-color: #667eea;
        }

        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .preference-option:hover .tooltip {
            opacity: 1;
        }
		
		/* UserPlus Premium Button Styles */
		.premium-btn {
			position: relative;
			transition: all 0.3s ease;
		}

		.premium-btn-active {
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			color: white;
			border: none;
		}

		.premium-btn-active:hover {
			background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
			transform: scale(1.05);
		}

		.premium-btn-locked {
			background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e0 100%);
			color: #a0aec0;
			border: 2px dashed #cbd5e0;
			cursor: not-allowed;
		}

		.premium-btn-locked:hover {
			background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
			border-color: #a0aec0;
			transform: none;
		}

		.premium-lock {
			position: absolute;
			top: -8px;
			right: -8px;
			background: #f56565;
			color: white;
			border-radius: 50%;
			width: 20px;
			height: 20px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 12px;
			box-shadow: 0 2px 4px rgba(0,0,0,0.2);
		}

		/* Floating buttons container */
		.floating-buttons {
			backdrop-filter: blur(10px);
			background: rgba(255, 255, 255, 0.1);
			border-radius: 50px;
			padding: 8px;
			box-shadow: 0 8px 32px rgba(0,0,0,0.1);
		}

		/* Premium feature highlight animation */
		@keyframes premiumPulse {
			0% { box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.7); }
			70% { box-shadow: 0 0 0 10px rgba(102, 126, 234, 0); }
			100% { box-shadow: 0 0 0 0 rgba(102, 126, 234, 0); }
		}

		.premium-btn-active:focus {
			animation: premiumPulse 2s infinite;
		}

		/* UserPlus badge in sidebar */
		.userplus-badge {
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			color: white;
			padding: 4px 8px;
			border-radius: 12px;
			font-size: 10px;
			font-weight: bold;
			margin-left: auto;
		}

		/* UserPlus modal animations */
		.userplus-modal-enter {
			animation: modalSlideIn 0.3s ease-out forwards;
		}

		@keyframes modalSlideIn {
			from {
				opacity: 0;
				transform: translateY(20px) scale(0.95);
			}
			to {
				opacity: 1;
				transform: translateY(0) scale(1);
			}
		}

		/* Premium feature tooltips */
		.premium-tooltip {
			position: absolute;
			bottom: 100%;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.8);
			color: white;
			padding: 8px 12px;
			border-radius: 8px;
			font-size: 12px;
			white-space: nowrap;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
			margin-bottom: 8px;
		}

		.premium-tooltip::after {
			content: '';
			position: absolute;
			top: 100%;
			left: 50%;
			transform: translateX(-50%);
			border: 4px solid transparent;
			border-top-color: rgba(0, 0, 0, 0.8);
		}

		.premium-btn:hover .premium-tooltip {
			opacity: 1;
		}

		/* Swipe back success animation */
		@keyframes swipeBackSuccess {
			0% { transform: scale(1); }
			50% { transform: scale(1.2); }
			100% { transform: scale(1); }
		}

		.swipe-back-success {
			animation: swipeBackSuccess 0.6s ease-in-out;
		}

		/* InstaMatch star effect */
		@keyframes starBurst {
			0% { 
				transform: scale(0) rotate(0deg);
				opacity: 1;
			}
			50% { 
				transform: scale(1.3) rotate(180deg);
				opacity: 0.8;
			}
			100% { 
				transform: scale(1.5) rotate(360deg);
				opacity: 0;
			}
		}

		.instamatch-star {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			color: #ffd700;
			font-size: 24px;
			animation: starBurst 1s ease-out forwards;
			pointer-events: none;
		}

		/* Premium card indicators */
		.premium-indicator {
			position: absolute;
			top: 10px;
			right: 10px;
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			color: white;
			padding: 4px 8px;
			border-radius: 12px;
			font-size: 10px;
			font-weight: bold;
			box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
		}		
		
		#matchesContainer {
			position: fixed !important;
			top: 50% !important;
			left: 50% !important;
			transform: translate(-50%, -50%) !important;
			z-index: 2000 !important;
			width: 90% !important;
			max-width: 500px !important;
			max-height: 90vh !important;
			overflow-y: auto !important;
		}
		
		#createProfileModal {
			/* ALLE !important überschreibungen hier löschen */
		}

		.modal-content.profile-creation {
		    position: fixed !important;
		    top: 50% !important;
		    left: 50% !important;
		    transform: translate(-50%, -50%) !important;
		    margin: 0 !important; /* Überschreibt das bestehende margin: 10% auto */
		    max-width: 600px;
		    width: 90%;
		    max-height: 90vh;
		    overflow-y: auto;
		}		
		/* Neue Klasse für zweispaltige Anordnung hinzufügen */
		.form-row {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 15px;
			margin-bottom: 20px;
		}

		@media (max-width: 768px) {
			.form-row {
				grid-template-columns: 1fr;
			}
		}

		.gender-selection {
			display: flex;
			gap: 10px;
			margin-bottom: 10px;
		}

		.gender-btn {
			flex: 1;
			padding: 12px;
			border: 2px solid rgba(255, 255, 255, 0.2);
			border-radius: 12px;
			background: rgba(255, 255, 255, 0.05);
			cursor: pointer;
			font-weight: bold;
			text-align: center;
			transition: all 0.3s ease;
			color: #ffffff;
			backdrop-filter: blur(10px);
		}

		.gender-btn:hover {
			border-color: rgba(102, 126, 234, 0.6);
			background: rgba(255, 255, 255, 0.08);
		}

		.gender-btn.selected {
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			color: white;
			border-color: #667eea;
		}

        .character-count {
            font-size: 12px;
            color: #b0b0b0;
            text-align: right;
            margin-top: 5px;
        }

        /* File Status */
        #fileStatus {
            margin-top: 10px;
            font-size: 0.85rem;
            color: #b0b0b0;
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .profile-creation {
                padding: 20px;
                margin: 20px;
            }
            
            .profile-creation h2 {
                font-size: 1.6rem;
            }
            
            .preferences-icons {
                gap: 15px;
            }
        }		

		@keyframes shimmer {
		    0% { background-position: -200% 0; }
		    100% { background-position: 200% 0; }
		}
		
		.ki-beta-container {
		    padding: 2px 10px; /* Innenabstand für eine sehr enge Darstellung */
		    border: 1px solid #333; /* Dunkler Rand, gut sichtbar */
		    border-radius: 200px; /* Abgerundete Ecken */
		    display: inline-block;
		}
		
		.ki-beta-branding {
		    font-weight: 600;
		    font-size: 0.65rem; /* Sehr kleine Schriftgröße */
		    letter-spacing: 0.05em;
		    opacity: 0.95;
		    /* Gradient von dunklem Silber zu hellem Silber */
		    background: linear-gradient(90deg, #555, #ccc, #555);
		    background-size: 200% 100%;
		    -webkit-background-clip: text;
		    -webkit-text-fill-color: transparent;
		    animation: shimmer 5s infinite linear;
		}

		/* Tipp-Effekt-Animation */
		@keyframes typing {
		    from { width: 0; }
		    to { width: 100%; }
		}
		
		.typing-animation {
		    overflow: hidden;
		    white-space: nowrap;
		    animation: typing 2.5s steps(22, end) forwards, blink-caret .75s step-end infinite;
		    display: inline-block;
		}
		
		@keyframes blink-caret {
		    from, to { border-color: transparent }
		    50% { border-color: #555; }
		}
		
		/* Versteckt den Container standardmäßig */
		.hidden {
		    display: none;
		}
		
		.typing-animation::after {
			content: '...';
			animation: typing 1.4s infinite;
		}

		@keyframes typing {
			0%, 20% { content: '.'; }
			40% { content: '..'; }
			60%, 100% { content: '...'; }
		}		

        /* Chat System */
		.chat-container {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			z-index: 2000;
			display: none;
			width: 90%;
			max-width: 500px;
			height: auto; /* Chat behält trotzdem seine Höhe */
			max-height: 90vh; /* verhindert, dass es zu groß wird */
			overflow-y: auto;
		}

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }

        .chat-back-btn {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .matches-list {
            padding: 20px;
            height: calc(100% - 80px);
            overflow-y: auto;
        }

		.match-item {
			position: relative;
		}

		.match-item::after {
			content: attr(data-distance);
			position: absolute;
			top: 10px;
			right: 15px;
			background: rgba(0,0,0,0.1);
			padding: 2px 8px;
			border-radius: 12px;
			font-size: 0.8rem;
			color: #666;
		}

		/* Responsive adjustments */
		@media (max-width: 480px) {
			.card-name {
				font-size: 1.3rem;
			}
			
			.card-distance {
				font-size: 0.8rem;
				padding: 3px 6px;
			}
			
			.card-header {
				flex-direction: column;
				align-items: flex-start;
				gap: 4px;
			}
			
			.card-distance {
				margin-left: 0;
				align-self: flex-end;
			}
		}

        /* Individual Chat */
        .individual-chat {
            display: none;
            height: 100%;
        }

        .individual-chat .chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .chat-user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .suggest-bench-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .suggest-bench-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .chat-messages {
            padding: 20px;
            height: calc(100% - 160px);
            overflow-y: auto;
        }

        .message {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
        }

        .message.sent {
            align-items: flex-end;
        }

        .message.received {
            align-items: flex-start;
        }

        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 20px;
            word-wrap: break-word;
        }

        .message.sent .message-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .message.received .message-bubble {
            background: #f1f1f1;
            color: #333;
        }

        .message-input-area {
            padding: 20px;
            border-top: 1px solid #eee;
            display: flex;
            gap: 10px;
        }

        .message-input {
            flex: 1;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
			color: #000;
        }

        .send-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .send-btn:hover {
            transform: scale(1.05);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .app-container {
                padding: 100px 10px 20px;
            }
            
            .welcome-screen h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div id="modalOverlay" class="fixed inset-0 bg-black opacity-50 z-10 hidden"></div>
	
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>
    <div class="main-logo" id="mainLogo" onclick="toggleSidebar()">
        <img src="OB.png" alt="OB Logo">
    </div>
    <div id="sidebar" class="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-logo" onclick="closeSidebar()">
                <img src="OB.png" alt="OB Logo" style="width: 100%; height: 100%; border-radius: 50%; object-fit: contain;">
            </div>
            <div class="sidebar-title">One-T-Meet</div>
        </div>
        <div class="sidebar-content">
			<a href="#" class="sidebar-item" id="loginSidebarBtn" onclick="showLogin()">
				<span class="sidebar-icon">🔐</span>
				<span>Anmelden</span>
			</a>
			<a href="#" class="sidebar-item" id="logoutSidebarBtn" style="display: none;" onclick="logout()">
				<span class="sidebar-icon">🚪</span>
				<span>Abmelden</span>
			</a>
            <a href="index.html" class="sidebar-item">
                <span class="sidebar-icon">🗺️</span>
                <span>Zur Bench-Karte</span>
            </a>
            <a href="contact.html" class="sidebar-item">
                <span class="sidebar-icon">📧</span>
                <span>Kontakt</span>
            </a>
        </div>
        <div class="sidebar-footer" id="user-email-display"></div>
    </div>
	
    <div id="loginModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeLogin()">&times;</span>
            <h2>Anmelden / Registrieren</h2>
            <div class="auth-tabs">
                <button class="tab-btn active" onclick="showTab('login', event)">Anmelden</button>
                <button class="tab-btn" onclick="showTab('register', event)">Registrieren</button>
            </div>
            <div id="loginTab" class="tab-content active">
                <form onsubmit="login(event)">
                    <input type="email" id="loginEmail" placeholder="E-Mail" required>
                    <input type="password" id="loginPassword" placeholder="Passwort" required>
                    <div class="captcha-box">
                        <p id="loginCaptcha"></p>
                        <input type="number" id="loginCaptchaAnswer" placeholder="Antwort" required>
                    </div>
                    <button type="submit">Anmelden</button>
                    <p style="margin-top:10px;">
                        <a href="#" onclick="showPasswordResetForm(event)">Passwort vergessen?</a>
                    </p>
                </form>
            </div>
			
            <div id="registerTab" class="tab-content">
                <form onsubmit="register(event)">
                    <input type="email" id="registerEmail" placeholder="E-Mail" required>
                    <input type="password" id="registerPassword" placeholder="Passwort" required>
                    <input type="password" id="registerPasswordConfirm" placeholder="Passwort bestätigen" required>
                    <div class="captcha-box">
                        <p id="registerCaptcha"></p>
                        <input type="number" id="registerCaptchaAnswer" placeholder="Antwort" required>
                    </div>
                    <button type="submit">Registrieren</button>
                </form>
            </div>
            <div id="passwordResetDiv" style="display:none;">
                <form onsubmit="event.preventDefault(); requestPasswordReset();">
                    <input type="email" id="resetEmail" placeholder="E-Mail zum Zurücksetzen" required>
                    <button type="submit">Passwort zurücksetzen</button>
                    <button type="button" onclick="hidePasswordResetForm()">Abbrechen</button>
                </form>
            </div>
        </div>
    </div>
    
	<div class="app-container">
		<div id="welcomeScreen" style="padding:4rem 2rem; max-width:900px; margin:0 auto; text-align:center;">


			<h1 class="shimmer" style="font-size:2.8rem; margin-bottom:1rem;">OneConnect</h1>
			<h2 class="shimmer" style="font-size:1.5rem; margin-bottom:3rem;">One-To-Meet x OneBenches</h2>

			<div style="margin-bottom:3rem; font-size:1rem; line-height:1.6;">
				<p>Registrieren</p>
				<p>Profil erstellen</p>
				<div style="margin-bottom:3rem;">
					<button class="white-btn" onclick="showLogin()">Loslegen</button>
				</div>
			</div>

			<h3 style="font-size:1.3rem; margin-bottom:1rem;">One-To-Meet ist die Zukunft</h3>
			<p style="margin-bottom:3rem;">Online Dating ohne Limit</p>

			<!-- Vergleichstabelle -->
			<table style="width:100%; border-collapse:collapse; margin-bottom:4rem; text-align:center; font-size:0.9rem;">
				<tr>
					<th style="border:1px solid #888; padding:8px;">&nbsp;</th>
					<th style="border:1px solid #888; padding:8px;">One-To-Meet</th>
					<th style="border:1px solid #888; padding:8px;">Standard Date-Apps</th>
				</tr>
				<tr>
					<td style="border:1px solid #888; padding:8px;">Kostenlos Unendlich Swipen</td>
					<td style="border:1px solid #888; padding:8px;">✅</td>
					<td style="border:1px solid #888; padding:8px;">❌</td>
				</tr>
				<tr>
					<td style="border:1px solid #888; padding:8px;">Ohne Begrenzung Daten</td>
					<td style="border:1px solid #888; padding:8px;">✅</td>
					<td style="border:1px solid #888; padding:8px;">❌</td>
				</tr>
				<tr>
					<td style="border:1px solid #888; padding:8px;">Date-Chat KI Unterstützung</td>
					<td style="border:1px solid #888; padding:8px;">✅</td>
					<td style="border:1px solid #888; padding:8px;">❌</td>
				</tr>
			</table>

			<h2 style="margin:3rem 0;" class="shimmer">x OneBenches x</h2>

			<p style="max-width:700px; margin:0 auto 2rem auto; line-height:1.6; font-size:0.95rem;">
				Erstelle und Suche Bänke in deiner Gegend – beim Wandern, mit deinen Freunden oder deinem Date.<br>
				Beim Sonnenuntergang Wein trinken oder eine Tüte zünden.
			</p>

			<h2 style="margin-bottom:2rem;" class="shimmer">x OneBenches x</h2>
			<p style="margin-bottom:3rem;">Komm raus mit OneBenches</p>

			<blockquote style="font-style:italic; opacity:0.8; font-size:0.9rem;">“Peace can’t be found without searching”</blockquote>
		</div>

	    
	    <div id="createProfileSection" class="relative z-0 p-4 w-full h-screen flex flex-col items-center justify-center" style="display: none;">
	        <button onclick="showCreateProfileForm()" class="bg-white text-blue-600 font-bold py-4 px-8 rounded-full shadow-lg hover:bg-gray-200 transition duration-300 transform scale-105 hover:scale-110">
	            <span class="text-xl">Profil erstellen</span>
	        </button>
	    </div>	    
	
		<div id="createProfileModal" class="modal" style="display: none;">
			<div class="modal-content profile-creation">
				<span class="close" onclick="closeCreateProfile()">&times;</span>
				<h2 class="shimmer">Erstelle dein Profil</h2>
				<form id="profileForm">
			
					<!-- Gender Selection -->
					<div class="form-group">
						<label>Geschlecht:</label>
						<div class="gender-selection">
							<div class="gender-btn" data-gender="male">👨 Männlich</div>
							<div class="gender-btn" data-gender="female">👩 Weiblich</div>
						</div>
						<div id="genderError" class="error" style="display: none;"></div>
					</div>

					<!-- Profile Image -->
					<div class="form-group">
						<label>Profilbild:</label>
						<div class="modern-file-upload">
							<button type="button" class="file-upload-btn" onclick="document.getElementById('profileImage').click()">
								<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
									<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
								</svg>
								<span id="fileButtonText">Bild auswählen</span>
							</button>
							<input type="file" id="profileImage" accept="image/*" required style="display: none;">
							<div id="fileStatus">Kein Bild ausgewählt</div>
						</div>
					</div>

					<!-- Name and Age Row -->
					<div class="form-row">
						<div class="form-group">
							<label>👤 Name:</label>
							<input type="text" id="profileName" placeholder="Dein Name" maxlength="16" required>
							<div id="nameError" class="error" style="display: none;"></div>
							<div id="nameCount" class="character-count">0/16</div>
						</div>
						<div class="form-group">
							<label>🎂 Alter:</label>
							<input type="number" id="profileAge" placeholder="Dein Alter" min="18" max="99" required>
							<div id="ageError" class="error" style="display: none;"></div>
						</div>
					</div>

					<!-- Postal Code - Smaller -->
					<div class="form-group">
						<label for="postalCode">Postleitzahl:</label>
						<input type="text" id="postalCode" placeholder="z.B. 10115" maxlength="10">
					</div>

					<!-- Description -->
					<div class="form-group">
						<label>📝 Kurze Beschreibung (max. 2 Sätze):</label>
						<textarea id="profileDescription" rows="3" placeholder="Erzähl etwas über dich..." maxlength="200" required></textarea>
						<div id="descriptionError" class="error" style="display: none;"></div>
						<div id="descriptionCount" class="character-count">0/200</div>
					</div>


					<!-- Genussmittel -->
					<div class="form-group">
						<label>Genussmittel:</label>
						<div id="preferencesIcons" class="preferences-icons"></div>
					</div>

					<!-- Hobbies -->
					<div class="form-group">
						<label>Wähle deine Interessen:</label>
						<div id="hobbiesIcons" class="preferences-icons"></div>
					</div>

					<!-- Questions -->
					<div class="form-group">
						<label>Wähle 2 Fragen über dich:</label>
						<select id="prompt1Select" required>
							<option value="">Wähle eine Frage aus...</option>
							<option value="Ein perfekter erster Date ist...">Ein perfekter erster Date ist...</option>
							<option value="Ich bin gerade besessen von...">Ich bin gerade besessen von...</option>
							<option value="Zwei Wahrheiten und eine Lüge...">Zwei Wahrheiten und eine Lüge...</option>
							<option value="Mein liebstes Reiseziel ist...">Mein liebstes Reiseziel ist...</option>
							<option value="Was ich in meiner Freizeit tue...">Was ich in meiner Freizeit tue...</option>
						</select>
						<input type="text" id="answer1Input" placeholder="Deine Antwort..." style="margin-top: 10px;">
					</div>

					<div class="form-group">
						<select id="prompt2Select" required>
							<option value="">Wähle eine zweite Frage aus...</option>
							<option value="Ein perfekter erster Date ist...">Ein perfekter erster Date ist...</option>
							<option value="Ich bin gerade besessen von...">Ich bin gerade besessen von...</option>
							<option value="Zwei Wahrheiten und eine Lüge...">Zwei Wahrheiten und eine Lüge...</option>
							<option value="Mein liebstes Reiseziel ist...">Mein liebstes Reiseziel ist...</option>
							<option value="Was ich in meiner Freizeit tue...">Was ich in meiner Freizeit tue...</option>
						</select>
						<input type="text" id="answer2Input" placeholder="Deine Antwort..." style="margin-top: 10px;">
					</div>

					<div class="action-buttons">
						<button type="submit" class="action-btn btn-primary">
							Profil speichern
						</button>
						<button type="button" class="action-btn btn-secondary" onclick="closeCreateProfile()">
							Zurück
						</button>
					</div>
				</form>
			</div>
		</div>
	    
		<div id="swipeContainer" class="swipe-container" style="display: none;">
			<div class="card-stack" id="cardStack">
			</div>
			<div id="noMoreProfiles" style="text-align: center; color: white; display: none;">
				<h2 class="text-2xl font-bold">Keine weiteren Profile gefunden 😢</h2>
				<p class="mt-2">Versuch es später noch einmal oder passe deine Sucheinstellungen an.</p>
			</div>
			<div class="swipe-actions">
				<button class="swipe-btn dislike" onclick="swipeCard('left')">❌</button>
				<button class="swipe-btn like" onclick="swipeCard('right')">💖</button>
			</div>
		</div>
	
	    <div id="matchesContainer" class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg mx-auto" style="display: none;">
	        <h2 class="text-2xl font-bold mb-4 text-gray-800 text-center">Deine Matches</h2>
	        <div id="matchesList" class="space-y-4">
	            <p class="text-gray-500 text-center">Keine Matches gefunden.</p>
	        </div>
	    </div>
	</div>
	
	
	<div id="profilePopup" class="profile-popup" style="display: none;">
		<div class="flex justify-between items-start mb-4">
			<h2 class="text-2xl font-bold shimmer" id="popupProfileName"></h2>
			<button onclick="closeProfilePopup()" class="text-gray-500 hover:text-gray-700 transition-colors">
				<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
				</svg>
			</button>
		</div>
		
		<div class="flex flex-col items-center">
			<img id="popupProfileImage" src="" alt="Profilbild" class="w-32 h-32 rounded-full object-cover mb-4">
			
			<!-- Distance und zusätzliche Info -->
			<p id="popupProfileDistance" class="text-gray-500 text-sm mb-2"></p>
			
			<!-- Zusätzliche Profil-Infos -->
			<div class="profile-additional-info">
				<div class="profile-info-row">
					<span class="profile-info-label">Geschlecht:</span>
					<span class="profile-info-value" id="popupProfileGender">-</span>
				</div>
				<div class="profile-info-row">
					<span class="profile-info-label">PLZ:</span>
					<span class="profile-info-value" id="popupProfilePostal">-</span>
				</div>
			</div>
			
			<!-- Description -->
			<p id="popupProfileDescription" class="text-gray-600 text-center mb-4"></p>
			
			<!-- Interests -->
			<div class="flex flex-wrap gap-2 justify-center mb-6" id="popupProfileInterests"></div>
			
			<!-- Q&A Section -->
			<div class="profile-qa-section" id="popupProfileQA">
				<div class="profile-qa-item" id="qa1Container" style="display: none;">
					<div class="profile-qa-question" id="popupPrompt1"></div>
					<div class="profile-qa-answer" id="popupAnswer1"></div>
				</div>
				<div class="profile-qa-item" id="qa2Container" style="display: none;">
					<div class="profile-qa-question" id="popupPrompt2"></div>
					<div class="profile-qa-answer" id="popupAnswer2"></div>
				</div>
			</div>
			
			<!-- Action Buttons -->
			<div class="flex space-x-4">
				<button onclick="editProfile()" class="bg-green-500 text-white font-bold py-2 px-4 rounded-lg shadow hover:bg-green-600 transition-colors">
					Profil bearbeiten
				</button>
				<button onclick="deleteProfile()" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg shadow hover:bg-red-600 transition-colors">
					Profil löschen
				</button>
			</div>
		</div>
	</div>

	<button id="profileButton" class="floating-button profile-button hidden" onclick="showProfilePopup()">
	    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>
	</button>
	<button id="chatButton" class="floating-button chat-button hidden" onclick="showMatches()">
	    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path></svg>
	</button>
</body>

    <!-- Notification -->
    <div id="notification" class="notification"></div>

	<script>
        // Global Variables
        let currentUser = null;
		let loginCaptcha = null, registerCaptcha = null;
        let sidebarOpen = false;
        let currentProfile = null;
        let sampleProfiles = [];
        let currentCardIndex = 0;
        let matches = [];
        let currentChatUser = null;
        let selectedPreferences = [];		
		let currentProfiles = [];
		let currentIndex = 0;
		let currentSwipeUser = null;
		let currentUserId = localStorage.getItem('currentUserId');
		let isSwipeInProgress = false;
		let selectedHobbies = [];
		let unreadMessageCount = 0;
		let lastCheckedMessages = {};
		let lastMatchesHash = null;
		let matchesRefreshInterval = null;
		let isUserPlus = false;
		let isAdmin = false;
		let lastSwipedProfile = null;
		let selectedGender = null;

				
		let chatState = {
			currentMatchId: null,
			currentConversationId: null,
			aiSuggestionsLoaded: false,
			lastLoadedMessageCount: 0,
			messageInterval: null,
			isAI: false,        // Flag, ob Chat mit AI ist
			aiProfileId: null   // die AI-Profil-ID für diesen Chat
		};
	
		const emojiMap = {
			'alcohol': '🍷',
			'smoking': '🚬',
			'420': '🍁',
			'coffee': '☕',
			'none': '🚫'
		};

		const hobbiesMap = {
			'Kochen': '👩‍🍳',
			'Gaming': '🎮',
			'Wandern': '⛰️',
			'Fotografie': '📸',
			'Musik': '🎵',
			'Filme': '🎬',
			'Sport': '🏋️',
			'Kunst': '🎨',
			'Haustiere': '🐶',
			'Reisen': '🌍',
			'Essen & Trinken': '🍽️',
			'Lesen': '📚',
			'Technologie': '💻',
			'Kino': '🍿',
			'Strand': '🏖️',
			'Ausgehen': '🎉',
			'Konzerte': '🎤',
			'Sprachen': '🗣️',
			'Ehrenamt': '🤝',
			'Kultur': '🏛️',
			'Politik': '🗳️',
			'Natur': '🌲'
		};

		const apiUrl = 'https://onebenches.dpdns.org'; 
		
				
		// ---------------------------
		// AI Timer / Scheduler global + persistent via localStorage
		// ---------------------------
		window.aiReplyTimers = window.aiReplyTimers || {};

		function persistTimerToStorage(convId, meta) {
		  try {
			localStorage.setItem(`ai_timer_${convId}`, JSON.stringify(meta));
		  } catch (e) {}
		}
		function removeTimerFromStorage(convId) {
		  try { localStorage.removeItem(`ai_timer_${convId}`); } catch (e) {}
		}

		function restoreAiTimers() {
		  try {
			Object.keys(localStorage).forEach(k => {
			  if (!k.startsWith('ai_timer_')) return;
			  const convId = k.replace('ai_timer_', '');
			  const meta = JSON.parse(localStorage.getItem(k) || '{}');
			  if (!meta || !meta.dueAt) {
				removeTimerFromStorage(convId);
				return;
			  }
			  const remaining = Math.max(meta.dueAt - Date.now(), 0);
			  if (window.aiReplyTimers[convId] && window.aiReplyTimers[convId].id) return;

			  window.aiReplyTimers[convId] = {
				pendingUserMessages: meta.pendingUserMessages || [],
				dueAt: meta.dueAt,
				id: setTimeout(() => triggerAiReply(convId), remaining)
			  };
			});
		  } catch (e) { console.error('restoreAiTimers error', e); }
		}

		document.addEventListener('DOMContentLoaded', () => {
		  restoreAiTimers();
		});
		


        // Sidebar Functions
        function toggleSidebar() {
            if (sidebarOpen) {
                closeSidebar();
            } else {
                openSidebar();
            }
        }
        
        function openSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const mainLogo = document.getElementById('mainLogo');
            
            sidebarOpen = true;
            sidebar.classList.add('open');
            overlay.classList.add('active');
            mainLogo.classList.add('sidebar-open');
        }
        
        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const mainLogo = document.getElementById('mainLogo');
            
            sidebarOpen = false;
            sidebar.classList.remove('open');
            overlay.classList.remove('active');
            mainLogo.classList.remove('sidebar-open');
        }

        // Auth Functions
        function showLogin() {
            document.getElementById('loginModal').style.display = 'block';
			generateCaptchas();
        }
        
        function closeLogin() {
            document.getElementById('loginModal').style.display = 'none';
        }
        
        function showTab(tab, event) {
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));

            document.getElementById(tab + 'Tab').classList.add('active');
            
            if (event && event.target) {
                event.target.classList.add('active');
            }
        }
		
        function generateCaptchas() {
            loginCaptcha = generateCaptcha();
            registerCaptcha = generateCaptcha();
            document.getElementById('loginCaptcha').textContent = `🤖 Sind Sie ein Roboter? ${loginCaptcha.question}`;
            document.getElementById('registerCaptcha').textContent = `🤖 Sind Sie ein Roboter? ${registerCaptcha.question}`;
        }
        
        function generateCaptcha() {
            const operations = [
                () => {
                    const a = Math.floor(Math.random() * 10) + 1;
                    const b = Math.floor(Math.random() * 10) + 1;
                    return { question: `${a} + ${b} = ?`, answer: a + b };
                },
                () => {
                    const a = Math.floor(Math.random() * 10) + 5;
                    const b = Math.floor(Math.random() * 5) + 1;
                    return { question: `${a} - ${b} = ?`, answer: a - b };
                },
                () => {
                    const a = Math.floor(Math.random() * 5) + 2;
                    const b = Math.floor(Math.random() * 5) + 2;
                    return { question: `${a} × ${b} = ?`, answer: a * b };
                }
            ];
            return operations[Math.floor(Math.random() * operations.length)]();
        }		

		async function register(event) {
			event.preventDefault();
			const email = document.getElementById('registerEmail').value;
			const password = document.getElementById('registerPassword').value;
			const passwordConfirm = document.getElementById('registerPasswordConfirm').value;
			const captchaAnswer = parseInt(document.getElementById('registerCaptchaAnswer').value);

			if (password !== passwordConfirm) {
				showNotification('Passwörter stimmen nicht überein!', 'error');
				return;
			}

			if (password.length < 6) {
				showNotification('Passwort muss mindestens 6 Zeichen lang sein!', 'error');
				return;
			}
			
            if (captchaAnswer !== registerCaptcha.answer) {
                showNotification('Falsche CAPTCHA-Antwort! Bitte versuchen Sie es erneut.', 'error');
                generateCaptchas();
                document.getElementById('registerCaptchaAnswer').value = '';
                return;
            }

			try {
				// Verwende deine bestehende auth.js Funktion (gleich wie index.html)
				const response = await fetch('/.netlify/functions/auth', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ 
						action: 'register', 
						email: email, 
						password: password 
					})
				});

				const result = await response.json();

				if (result.success) {
					showNotification('✅ ' + result.message, 'success');
					showTab('login');
				} else {
					showNotification('❌ ' + result.error, 'error');
				}
			} catch (error) {
				console.error('Registration error:', error);
				showNotification('❌ Verbindungsfehler bei der Registrierung', 'error');
			}
		}

		async function login(event) {
			event.preventDefault();
			const email = document.getElementById('loginEmail').value;
			const password = document.getElementById('loginPassword').value;
            const captchaAnswer = parseInt(document.getElementById('loginCaptchaAnswer').value);
			
            if (captchaAnswer !== loginCaptcha.answer) {
                showNotification('Falsche CAPTCHA-Antwort! Bitte versuchen Sie es erneut.', 'error');
                generateCaptchas();
                document.getElementById('loginCaptchaAnswer').value = '';
                return;			
			}

			try {
				const response = await fetch('/.netlify/functions/auth', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ 
						action: 'login', 
						email: email, 
						password: password 
					})
				});

				const result = await response.json();

				if (result.success) {
					currentUser = { 
						uid: result.userId,  // ← Jetzt kommt die echte DB-ID
						email: result.email, 
						isAdmin: result.isAdmin || false 
					};
					
					localStorage.setItem('currentUser', JSON.stringify(currentUser));
					
					closeLogin();
					updateAuthButtons();
					showNotification(`🎉 Willkommen ${currentUser.email}!`, 'success');
					
					document.getElementById('loginEmail').value = '';
					document.getElementById('loginPassword').value = '';
                    document.getElementById('loginCaptchaAnswer').value = '';					
					updateFloatingButtons(); // <-- Diese Zeile hinzufügen
					

					
				} else {
					showNotification('❌ ' + result.error, 'error');
				}
			} catch (error) {
				console.error('Login error:', error);
				showNotification('❌ Verbindungsfehler beim Anmelden', 'error');
			}
		}
		
        function logout() {
            currentUser = null;
            localStorage.removeItem('currentUser');
            updateAuthButtons();
            showNotification('👋 Erfolgreich abgemeldet!', 'success');
            showWelcome();
			window.location.reload(); 
        }

		function updateAuthButtons() {
			const userEmailDisplay = document.getElementById('user-email-display');
			const loginBtn = document.getElementById('loginSidebarBtn');
			const logoutBtn = document.getElementById('logoutSidebarBtn');
			
			// Prüfen, ob die Sidebar-Buttons existieren
			if (!loginBtn || !logoutBtn) {
				console.error('Login- oder Logout-Button in der Sidebar wurde nicht gefunden!');
				return;
			}

			if (currentUser) {
				// Angemeldet: Logout-Button anzeigen, Login-Button ausblenden
				loginBtn.style.display = 'none';
				logoutBtn.style.display = 'flex'; // Wichtig: flex, um das icon und den Text nebeneinander zu halten
				
				if (userEmailDisplay) {
					userEmailDisplay.innerHTML = `
						<span style="color: #333; background: rgba(76,175,80,0.1); padding: 8px 12px; border-radius: 5px; display: block; text-align: center;">
							👤 ${currentUser.email}
						</span>
					`;
				}
				
				// Nach Anmeldung prüfen ob Profil existiert
				checkAndRenderUI();
				setTimeout(initializeNotificationSystem, 1000);

			} else {
				// Nicht angemeldet: Anmelden-Button anzeigen, Logout-Button ausblenden
				loginBtn.style.display = 'flex'; // Wieder flex
				logoutBtn.style.display = 'none';
				
				if (userEmailDisplay) {
					userEmailDisplay.innerHTML = '';
				}
				
				unreadMessageCount = 0;
				lastCheckedMessages = {};
				updateChatButtonBadge();              
				
				// Floating buttons verstecken wenn nicht angemeldet
				document.getElementById('profileButton').classList.add('hidden');
				document.getElementById('chatButton').classList.add('hidden');
			}
		}
        // Navigation Functions
        function showWelcome() {
            hideAllScreens();
            document.getElementById('welcomeScreen').style.display = 'block';
        }

        function showProfileCreation() {
            if (!currentUser) {
                showLogin();
                showNotification('🔒 Sie müssen sich anmelden, um ein Profil zu erstellen!', 'error');
                return;
            }
            hideAllScreens();
            document.getElementById('profileCreation').style.display = 'block';
        }
		
		function showCreateProfileForm() {
		    closeProfilePopup(); // Stellt sicher, dass das Popup geschlossen ist
		    document.getElementById('createProfileSection').style.display = 'none';
		    document.getElementById('createProfileModal').style.display = 'block';
		    // Optional: Leeren Sie hier das Formular, falls nötig
		}

		function closeCreateProfile() {
			document.getElementById('createProfileSection').style.display = 'flex';
			document.getElementById('createProfileModal').style.display = 'none';
			
			// NEUE ZEILE: Zurück zum Swipe-Container wenn Profil existiert
			if (currentProfile) {
				checkAndRenderUI();
			}
		}

			
		async function showMatches() {
			if (!currentUser) {
				showLogin();
				showNotification('🔒 Bitte melden Sie sich an!', 'error');
				return;
			}
			
			hideAllScreens();
			document.getElementById('matchesContainer').style.display = 'block';
			
			// Floating buttons verstecken
			updateFloatingButtons();
			
			await loadUserMatches(true); // force refresh hinzufügen
			startMatchesAutoRefresh(); // Auto-refresh starten
			
			// Mark all messages as read when viewing matches list
			setTimeout(() => {
				const allMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
				const now = Date.now();
				allMatches.forEach(match => {
					lastCheckedMessages[match.match_id] = now;
				});
				localStorage.setItem('lastCheckedMessages', JSON.stringify(lastCheckedMessages));
				unreadMessageCount = 0;
				updateChatButtonBadge();
			}, 500);
		}
			
		async function loadUserMatches(forceRefresh = false) {
			const matchesList = document.getElementById('matchesList');
			
			if (!matchesList) {
				console.error('matchesList Element nicht gefunden');
				return;
			}
			
			// Nur Loading-Indikator beim ersten Laden zeigen
			if (!lastMatchesHash || forceRefresh) {
				matchesList.innerHTML = '<div class="text-center p-4">Lade Matches... 🔄</div>';
			}
			
			try {
				// Load real matches from server
				const response = await fetch('/.netlify/functions/get_matches', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});
				
				let allMatches = [];
				
				// Add real matches from database (including AI matches!)
				if (response.ok) {
					const result = await response.json();
					if (result.success && result.matches) {
						allMatches = [...result.matches];
						
						// For AI matches from database, get additional info from localStorage
						allMatches = allMatches.map(match => {
							// Check if this is an AI match (user_id_2 = 0 or any user with id 0)
							const isAIMatch = match.matched_user_id === 0 || match.matched_user_id === "0";
							
							if (isAIMatch) {
								// Get AI profile data from localStorage
								const localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
								const localAIMatch = localMatches.find(lm => lm.match_id === match.match_id);
								
								if (localAIMatch) {
									// Combine database match with localStorage AI profile data
									return {
										...match,
										isAI: true,
										profile_name: localAIMatch.profile_name,
										profile_image: localAIMatch.profile_image,
										description: localAIMatch.description,
										age: localAIMatch.age
									};
								}
							}
							
							return match;
						});
					}
				}
				
				// Create hash for comparison
				const currentHash = JSON.stringify(allMatches.map(m => ({
					id: m.match_id,
					lastMsg: m.last_message?.text || null,
					lastMsgTime: m.last_message?.sent_at || null
				})));
				
				// Only update UI if something changed
				if (currentHash !== lastMatchesHash || forceRefresh) {
					lastMatchesHash = currentHash;
					
					if (allMatches.length > 0) {
						matchesList.innerHTML = allMatches.map(match => {
							// Last message from DB
							const lastMsg = match.last_message
								? (match.last_message.sender_id == currentUser.uid
									? `Du: ${match.last_message.text}`
									: `${match.profile_name}: ${match.last_message.text}`)
								: "Noch keine Nachrichten";

							// Use the real match_id for AI matches too
							const matchId = match.match_id;
							const userId = match.matched_user_id;

							return `
								<div class="match-item bg-white p-4 rounded-lg shadow-sm border border-gray-200 hover:shadow-md transition-shadow cursor-pointer mb-3"
									onclick="openMatchChat('${matchId}', '${match.matched_user_id}', '${match.profile_name}', '${match.profile_image}')">
									<div class="flex items-center space-x-4">
										<div class="flex-shrink-0 relative">
											<img src="${match.profile_image}"
												 alt="${match.profile_name}"
												 class="w-16 h-16 rounded-full object-cover border-2 border-pink-200">
										</div>
										<div class="flex-1 min-w-0">
											<h4 class="font-semibold text-lg text-gray-900 truncate">
												${match.profile_name}, ${match.age || "?"} 
											</h4>
											<p class="text-sm text-gray-600 truncate">${lastMsg}</p>
											<span class="text-xs text-gray-400 bg-pink-100 px-2 py-1 rounded-full">
												${match.isAI ? '💕 Match' : '💕 Match'}
										   </span>
										</div>
									</div>
								</div>
							`;
						}).join('');
						
						
						// Add back button
						matchesList.innerHTML += `
							<div class="mt-6 text-center">
								<button onclick="showSwipeCards()" 
										class="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-6 py-3 rounded-full hover:from-purple-600 hover:to-pink-600 transition-colors font-semibold">
									← Zurück zum Swipen
								</button>
							</div>
						`;
					} else {
						matchesList.innerHTML = `
							<div class="text-center py-16">
								<div class="text-8xl mb-6">💔</div>
								<h3 class="text-2xl font-bold text-gray-700 mb-4">Noch keine Matches</h3>
								<p class="text-gray-500 mb-8 max-w-sm mx-auto">
									Keine Sorge! Swipe weiter nach rechts und finde deine perfekte Verbindung.
								</p>
								<button onclick="showSwipeCards()" 
										class="bg-gradient-to-r from-pink-500 to-red-500 text-white px-8 py-4 rounded-full hover:from-pink-600 hover:to-red-600 transition-colors font-semibold text-lg">
									💖 Jetzt swipen
								</button>
							</div>
						`;
					}
				}
				
			} catch (error) {
				console.error('Fehler beim Laden der Matches:', error);
				if (forceRefresh || !lastMatchesHash) {
					matchesList.innerHTML = `
						<div class="text-center py-16">
							<div class="text-6xl mb-4">⚠️</div>
							<h3 class="text-xl font-semibold text-gray-700 mb-2">Verbindungsfehler</h3>
							<p class="text-gray-500 mb-6">Matches konnten nicht geladen werden</p>
							<button onclick="loadUserMatches(true)" 
									class="bg-blue-500 text-white px-6 py-2 rounded-full hover:bg-blue-600 transition-colors">
								🔄 Erneut versuchen
							</button>
						</div>
					`;
				}
			}
		}

		// Angepasstes Auto-Refresh System
		function startMatchesAutoRefresh() {
			if (matchesRefreshInterval) {
				clearInterval(matchesRefreshInterval);
			}
			
			const matchesList = document.getElementById('matchesList');
			if (matchesList && matchesList.offsetParent !== null) {
				matchesRefreshInterval = setInterval(() => {
					const currentMatchesList = document.getElementById('matchesList');
					if (currentMatchesList && currentMatchesList.offsetParent !== null) {
						loadUserMatches(false); // false = kein force refresh
					} else {
						clearInterval(matchesRefreshInterval);
						matchesRefreshInterval = null;
						lastMatchesHash = null; // Reset hash when stopping
					}
				}, 15000); // Weniger häufig: alle 15 Sekunden
			}
		}

		function stopMatchesAutoRefresh() {
			if (matchesRefreshInterval) {
				clearInterval(matchesRefreshInterval);
				matchesRefreshInterval = null;
			}
			// Hash nicht resetten, damit beim nächsten Start verglichen werden kann
		}

		// Verbesserte Error-Behandlung für alle API-Calls
		async function safeApiCall(url, options, fallbackMessage) {
		    try {
		        const response = await fetch(url, options);
		        
		        if (!response.ok) {
		            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
		        }
		        
		        const result = await response.json();
		        return { success: true, data: result };
		        
		    } catch (error) {
		        console.error('API Call failed:', error);
		        showNotification(fallbackMessage || 'Ein Fehler ist aufgetreten', 'error');
		        return { success: false, error: error.message };
		    }
		}
		
		async function showProfilePopup() {
			if (!currentUser || !currentUser.uid) {
				showNotification('❌ Bitte melden Sie sich erneut an.', 'error');
				return;
			}
			
			try {
				const response = await fetch('/.netlify/functions/get_my_profile', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});

				const result = await response.json();

				if (response.ok && result.profile) {
					currentProfile = result.profile;

					// Name + Alter
					const nameText = currentProfile.profile_name || 'Unbekannt';
					const ageText = currentProfile.age ? `, ${currentProfile.age}` : '';
					document.getElementById('popupProfileName').textContent = nameText + ageText;

					// Profilbild
					document.getElementById('popupProfileImage').src = currentProfile.profile_image || '/default-avatar.jpg';
					
					// Beschreibung
					document.getElementById('popupProfileDescription').textContent = currentProfile.description || 'Keine Beschreibung verfügbar.';

					// Entfernung berechnen
					let distanceText = '';
					if (currentProfile.latitude && currentProfile.longitude && currentUser.latitude && currentUser.longitude) {
						const dist = calculateDistance(
							currentUser.latitude, currentUser.longitude,
							currentProfile.latitude, currentProfile.longitude
						);
						distanceText = `${dist} km entfernt`;
					}
					document.getElementById('popupProfileDistance').textContent = distanceText;
					document.getElementById('popupProfileDistance').style.display = distanceText ? 'block' : 'none';

					// Zusätzliche Infos
					document.getElementById('popupProfileGender').textContent = currentProfile.gender || 'Nicht angegeben';
					document.getElementById('popupProfilePostal').textContent = currentProfile.postal_code || 'Nicht angegeben';

					// Interessen
					const interestsDiv = document.getElementById('popupProfileInterests');
					interestsDiv.innerHTML = '';
					const allEmojis = {
						'alcohol': '🍷', 'smoking': '🚬', '420': '🍁', 'coffee': '☕', 'none': '🚫',
						'Sport': '🏋️', 'Musik': '🎵', 'Reisen': '🌍', 'Essen & Trinken': '🍽️', 
						'Lesen': '📚', 'Gaming': '🎮', 'Filme': '🎬', 'Serien': '📺',
						'Kochen': '👩‍🍳', 'Wandern': '⛰️', 'Fotografie': '📸', 'Tanzen': '💃', 
						'Kunst': '🎨', 'Fitness': '💪', 'Yoga': '🧘', 'Meditation': '🧘‍♂️',
						'Gartenarbeit': '🧑‍🌾', 'Tiere': '🐾', 'Shopping': '🛍️', 
						'Technologie': '💻', 'Bücher': '📖', 'Kino': '🍿', 'Strand': '🏖️',
						'Ausgehen': '🎉', 'Konzerte': '🎤', 'Sprachen': '🗣️', 'Ehrenamt': '🤝', 
						'Kultur': '🏛️', 'Politik': '🗳️', 'Natur': '🌲'
					};
					
					const interests = Array.isArray(currentProfile.interests) ? currentProfile.interests : 
									 (currentProfile.interests ? JSON.parse(currentProfile.interests) : []);
					
					interests.forEach(interest => {
						const span = document.createElement('span');
						const emoji = allEmojis[interest] || '❓';
						span.textContent = `${emoji} ${interest}`;
						span.className = 'px-3 py-1 bg-gray-200 text-gray-700 rounded-full text-sm font-medium mr-2 mb-2 inline-block';
						interestsDiv.appendChild(span);
					});

					// Q&A Bereiche
					const qa1Container = document.getElementById('qa1Container');
					const qa2Container = document.getElementById('qa2Container');
					
					if (currentProfile.prompt_1 && currentProfile.answer_1) {
						document.getElementById('popupPrompt1').textContent = currentProfile.prompt_1;
						document.getElementById('popupAnswer1').textContent = currentProfile.answer_1;
						qa1Container.style.display = 'block';
					} else {
						qa1Container.style.display = 'none';
					}
					
					if (currentProfile.prompt_2 && currentProfile.answer_2) {
						document.getElementById('popupPrompt2').textContent = currentProfile.prompt_2;
						document.getElementById('popupAnswer2').textContent = currentProfile.answer_2;
						qa2Container.style.display = 'block';
					} else {
						qa2Container.style.display = 'none';
					}

					// Modal anzeigen
					document.getElementById('profilePopup').style.display = 'block';
					document.getElementById('modalOverlay').style.display = 'block';
					
				} else {
					showNotification('❌ Fehler beim Laden des Profils: ' + (result.error || 'Unbekannter Fehler'), 'error');
				}
			} catch (error) {
				console.error('Fehler beim Anzeigen des Profil-Popups:', error);
				showNotification('Ein Fehler ist aufgetreten: ' + error.message, 'error');
			}
		}
		
		function closeProfilePopup() {
			document.getElementById('profilePopup').style.display = 'none';
			document.getElementById('modalOverlay').style.display = 'none';
		}
				
		async function editProfile() {
			if (!currentProfile) {
				showNotification('❌ Profil-Daten nicht verfügbar', 'error');
				return;
			}

			try {
				// Nicht editierbare Felder (readonly)
				const nameInput = document.getElementById('profileName');
				if (nameInput) {
					nameInput.value = currentProfile.profile_name || '';
					nameInput.readOnly = true;
				}

				const ageInput = document.getElementById('profileAge');
				if (ageInput) {
					ageInput.value = currentProfile.age || '';
					ageInput.readOnly = true;
				}

				// Editierbare Felder
				const descriptionInput = document.getElementById('profileDescription');
				if (descriptionInput) {
					descriptionInput.value = currentProfile.description || '';
				}

				const postalCodeInput = document.getElementById('postalCode');
				if (postalCodeInput) {
					postalCodeInput.value = currentProfile.postal_code || '';
				}

				const interests = Array.isArray(currentProfile.interests)
					? currentProfile.interests
					: (currentProfile.interests ? [currentProfile.interests] : []);

				const preferencesOptions = ['wine', '420', 'coffee', 'book', 'bike'];
				const hobbiesOptions = ['Kochen', 'Gaming', 'Wandern', 'Fotografie', 'Musik', 'Filme', 'Sport', 'Kunst', 'Haustiere'];

				selectedPreferences = interests.filter(i => preferencesOptions.includes(i));
				selectedHobbies = interests.filter(i => hobbiesOptions.includes(i));

				renderPreferences();
				renderHobbies();

				if (currentProfile.prompt_1) {
					const prompt1Select = document.getElementById('prompt1Select');
					const answer1Input = document.getElementById('answer1Input');
					if (prompt1Select) prompt1Select.value = currentProfile.prompt_1;
					if (answer1Input) answer1Input.value = currentProfile.answer_1 || '';
				}

				if (currentProfile.prompt_2) {
					const prompt2Select = document.getElementById('prompt2Select');
					const answer2Input = document.getElementById('answer2Input');
					if (prompt2Select) prompt2Select.value = currentProfile.prompt_2;
					if (answer2Input) answer2Input.value = currentProfile.answer_2 || '';
				}

				closeProfilePopup();
				showCreateProfileForm();

				// Formular-Anpassungen
				document.getElementById('createProfileSection').style.display = 'none';
				const formTitle = document.querySelector('#createProfileModal h2');
				if (formTitle) formTitle.textContent = '✏️ Profil bearbeiten';

				const submitBtn = document.querySelector('#createProfileModal button[type="submit"]');
				if (submitBtn) submitBtn.innerHTML = '💾 Änderungen speichern';
				// Gender komplett ausblenden beim Edit
				const genderGroup = document.querySelector('.form-group label + .gender-selection')?.parentElement;
				if (genderGroup) {
				    genderGroup.style.display = 'none';
				}

			} catch (error) {
				console.error('Fehler beim Bearbeiten:', error);
				showNotification('Fehler beim Laden der Profil-Daten', 'error');
			}
		}



		function renderPreferences() {
		    const preferencesDiv = document.getElementById('preferencesIcons');
		    if (preferencesDiv) {
		        preferencesDiv.innerHTML = ''; // Vorherige Icons leeren
		        
		        // Definiere verfügbare Präferenzen mit ihren Emojis
		        const preferencesOptions = {
					'alcohol': '🍷',
					'smoking': '🚬',
					'420': '🍁',
					'coffee': '☕',
					'none': '🚫'
		        };
		        
		        Object.entries(preferencesOptions).forEach(([pref, emoji]) => {
		            const isSelected = selectedPreferences.includes(pref) ? 'selected' : '';
		            const option = document.createElement('div');
		            option.className = `preference-option ${isSelected}`;
		            option.dataset.value = pref; // WICHTIG: data-value setzen
		            option.setAttribute('onclick', `togglePreference(this, '${pref}')`);
		            option.innerHTML = `<span>${emoji}</span><div class="tooltip">${pref}</div>`;
		            preferencesDiv.appendChild(option);
		        });
		    }
		}		

		// Ihre neue Render-Funktion für Hobbies
		function renderHobbies() {
		    const hobbiesDiv = document.getElementById('hobbiesIcons');
		    if (!hobbiesDiv) return;
		    
		    hobbiesDiv.innerHTML = ''; 
		    
		    const hobbiesOptions = {
				'Kochen': '👩‍🍳',
				'Gaming': '🎮',
				'Wandern': '⛰️',
				'Fotografie': '📸',
				'Musik': '🎵',
				'Filme': '🎬',
				'Sport': '🏋️',
				'Kunst': '🎨',
				'Haustiere': '🐶',
				'Reisen': '🌍',
				'Essen & Trinken': '🍽️',
				'Lesen': '📚',
				'Technologie': '💻',
				'Kino': '🍿',
				'Strand': '🏖️',
				'Ausgehen': '🎉',
				'Konzerte': '🎤',
				'Sprachen': '🗣️',
				'Ehrenamt': '🤝',
				'Kultur': '🏛️',
				'Politik': '🗳️',
				'Natur': '🌲'
		    };
		    
		    Object.entries(hobbiesOptions).forEach(([hobby, emoji]) => {
		        const isSelected = selectedHobbies.includes(hobby) ? 'selected' : '';
		        const option = document.createElement('div');
		        option.className = `preference-option ${isSelected}`;
		        option.dataset.value = hobby; // WICHTIG: data-value setzen
		        option.setAttribute('onclick', `toggleHobby(this, '${hobby}')`);
		        option.innerHTML = `<span>${emoji}</span><div class="tooltip">${hobby}</div>`;
		        hobbiesDiv.appendChild(option);
		    });
		}
		
		// Ihre neue Funktion zum Umschalten der Hobbies mit Limit
		function toggleHobby(element, hobby) {
		    const maxHobbies = 5;
		    if (selectedHobbies.includes(hobby)) {
		        selectedHobbies = selectedHobbies.filter(h => h !== hobby);
		        element.classList.remove('selected');
		    } else {
		        if (selectedHobbies.length < maxHobbies) {
		            selectedHobbies.push(hobby);
		            element.classList.add('selected');
		        } else {
		            alert(`Du kannst maximal ${maxHobbies} Hobbies auswählen.`);
		        }
		    }
		}		

		async function deleteProfile() {
		    if (!confirm("Sind Sie sicher, dass Sie Ihr Profil löschen möchten?")) {
		        return;
		    }
		    try {
		        const response = await fetch('/.netlify/functions/delete_profile', {
		            method: 'DELETE',
		            headers: { 'Content-Type': 'application/json' },
		            body: JSON.stringify({ userId: currentUser.uid })
		        });
		
		        // Überprüfen Sie den Statuscode, bevor Sie die Antwort parsen
		        if (response.ok) {
		            const result = await response.json();
		            if (result.success) {
		                showNotification('✅ Profil erfolgreich gelöscht!', 'success');
		                closeProfilePopup();
		                checkAndRenderUI();
						window.location.reload(); 
		            } else {
		                showNotification('❌ Fehler beim Löschen des Profils: ' + result.error, 'error');
		            }
		        } else {
		            // Wenn die Antwort nicht erfolgreich ist, verarbeiten Sie den Fehlertext
		            const errorText = await response.text();
		            showNotification('❌ Fehler beim Löschen des Profils: ' + errorText, 'error');
		        }
		    } catch (error) {
		        showNotification('Ein Fehler ist aufgetreten: ' + error.message, 'error');
		    }
		}
		
		async function checkAndRenderUI() {
			hideAllScreens();
			
			if (!currentUser || !currentUser.uid) {
				// Zustand: Nicht angemeldet
				document.getElementById('welcomeScreen').style.display = 'block';
				updateFloatingButtons();
				// NEU: Scrollen für den Willkommensbildschirm aktivieren
				document.body.style.overflow = 'auto';
				return;
			}

			// Zustand: Angemeldet (unabhängig vom Profilstatus)
			// NEU: Scrollen für alle folgenden Ansichten deaktivieren
			document.body.style.overflow = 'hidden';

			try {
				const response = await fetch('/.netlify/functions/check_profile', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});

				const result = await response.json();

				if (result.hasProfile) {
					showSwipeCards();
					await initializeUserPlusFeatures();
					await loadProfiles();
				} else {
					showCreateProfileSection();
					updateFloatingButtons();
				}

			} catch (error) {
				console.error('Fehler beim Prüfen des Profils:', error);
				showNotification('⚠️ Fehler beim Laden. Bitte versuchen Sie es erneut.', 'error');
				document.getElementById('welcomeScreen').style.display = 'block';
				updateFloatingButtons();
				// NEU: Scrollen im Fehlerfall wieder aktivieren, da der Welcome Screen angezeigt wird
				document.body.style.overflow = 'auto';
			}
		}
		
		// ✅ NEW: Unified function to show "no more profiles" message
		function showNoMoreProfilesInCardStack() {
			const cardStack = document.getElementById('cardStack');
			const swipeActions = document.querySelector('.swipe-actions');
			const backButtonContainer = document.querySelector('div[style*="text-align: center; margin-top: 20px;"]');
			
			// Hide swipe actions and back button
			if (swipeActions) {
				swipeActions.style.display = 'none';
			}
			if (backButtonContainer) {
				backButtonContainer.style.display = 'none';
			}
			
			// Set cardStack to use the same positioning as loadSwipeCards
			cardStack.style.cssText = '';
			cardStack.innerHTML = `
				<div class="text-center p-12 flex flex-col items-center justify-center h-full">
					<div class="text-6xl mb-4">😞</div>
					<h3 class="text-xl font-bold text-gray-700 mb-2">Keine weiteren Profile gefunden</h3>
					<p class="text-gray-500 mb-6">Versuch es später noch einmal oder passe deine Sucheinstellungen an.</p>
					<button onclick="reloadProfiles()" class="bg-blue-500 text-white px-6 py-3 rounded-full hover:bg-blue-600 mb-4">
						🔄 Erneut versuchen
					</button>
				</div>
			`;
			
			// ✅ FIX: Make sure floating buttons are visible
			updateFloatingButtons();
		}
				
		
		async function loadProfiles() {
			console.log('🔄 Profile werden geladen...');
			const cardStack = document.getElementById('cardStack');
			if (!cardStack) {
				console.log('cardStack noch nicht bereit, versuche erneut...');
				setTimeout(loadProfiles, 100);
				return;
			}
			try {
				// Get both profiles and existing matches
				const [profilesResponse, matchesResponse] = await Promise.all([
					fetch('/.netlify/functions/get_profile', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ userId: currentUser.uid })
					}),
					fetch('/.netlify/functions/get_matches', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ userId: currentUser.uid })
					})
				]);
				
				const profilesResult = await profilesResponse.json();
				const matchesResult = await matchesResponse.json();
				
				// Lokale Matches laden (für AI-Profile)
				let localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
				
				const matchedUserIds = matchesResult.success && matchesResult.matches 
					? matchesResult.matches
						.filter(m => !m.isAI)
						.map(m => m.matched_user_id || m.user_id)
					: [];

				// KORRIGIERT: Bereits gematchte AI-Profile-IDs extrahieren
				const matchedAIProfileIds = localMatches
					.filter(m => m.isAI && m.ai_profile_id) // ai_profile_id muss existieren
					.map(m => m.ai_profile_id); // Echte AI-Profile-ID, nicht match_id
					  
				// --- Echte Profile ---
				let realProfiles = [];
				if (profilesResponse.ok && profilesResult.success && profilesResult.profiles) {
					realProfiles = profilesResult.profiles.filter(p => 
						p.user_id !== currentUser.uid && 
						!matchedUserIds.includes(p.user_id)
					);
				}
				
				// --- AI Profile ---
				let aiProfiles = [];
				if (realProfiles.length < 5) {
					const myProfile = JSON.parse(localStorage.getItem('currentProfile') || '{}');
					const userGender = myProfile.gender;
					const targetGender = userGender === 'male' ? 'female' : 'male';
					
					try {
						const res = await fetch('/.netlify/functions/generate_ai_profiles');
						const data = await res.json();
						aiProfiles = data.profiles
							.filter(p => p.gender === targetGender)
							.filter(p => !matchedAIProfileIds.includes(p.id)) // KORRIGIERT: Echte ID-Vergleich
							.map(p => ({ ...p, isAI: true })); // ID bleibt original
					} catch (err) {
						console.error("Fehler beim Laden der AI-Profile:", err);
					}
				}
				
				const allProfiles = [...realProfiles, ...aiProfiles];
				currentProfiles = allProfiles;
				
				if (currentProfiles.length > 0) {
					console.log(`🎯 ${currentProfiles.length} Profile geladen (${realProfiles.length} echt, ${currentProfiles.length - realProfiles.length} KI)`);
					currentIndex = 0;
					renderSwipeCards();
				} else {
					showNoMoreProfilesInCardStack();
				}
			} catch (error) {
				console.error('Fehler beim Laden der Profile:', error);
				showNoMoreProfilesInCardStack();
			}		
		}
		
		function showCreateProfileSection() {
			hideAllScreens();
			document.getElementById('createProfileSection').style.display = 'flex';
		}
		
		function showSwipeCards() {
			hideAllScreens();
			stopMatchesAutoRefresh();
			const swipeContainer = document.getElementById('swipeContainer');
			swipeContainer.style.display = 'block';
			
			// Ensure the cardStack is properly centered
			const cardStack = document.getElementById('cardStack');
			if (cardStack) {
				cardStack.style.display = 'flex';
				cardStack.style.alignItems = 'center';
				cardStack.style.justifyContent = 'center';
				cardStack.style.minHeight = '60vh';
			}
			
			document.getElementById('noMoreProfiles').style.display = 'none';
		}

        function showChats() {
            if (!currentUser) {
                showLogin();
                showNotification('🔒 Sie müssen sich anmelden, um Ihre Matches zu sehen!', 'error');
                return;
            }
            hideAllScreens();
            document.getElementById('chatContainer').style.display = 'block';
            showMatchesList();
        }

		function hideAllScreens() {
		    // Fügen Sie hier alle IDs Ihrer Haupt-Bildschirme hinzu,
		    // die beim Start ausgeblendet werden sollen.
		    const screens = [
		        'welcomeScreen', 
		        'createProfileSection', 
		        'createProfileModal', 
		        'matchesContainer', 
		        'profilePopup'
		    ];
		    
		    screens.forEach(id => {
		        const element = document.getElementById(id);
		        if (element) { // Wichtige Prüfung, ob das Element existiert
		            element.style.display = 'none';
		        }
		    });
		}

        // Profile Creation Functions
		function togglePreference(element, pref) {
			if (selectedPreferences.includes(pref)) {
				selectedPreferences = selectedPreferences.filter(p => p !== pref);
				element.classList.remove('selected');
			} else {
				selectedPreferences.push(pref);
				element.classList.add('selected');
			}
		}

		async function createProfile(event) {
			event.preventDefault();

			if (!currentUser || !currentUser.uid) {
				showNotification('❌ Fehler: Bitte melden Sie sich erneut an.', 'error');
				return;
			}

			const name = document.getElementById('profileName').value;
			const age = document.getElementById('profileAge').value;
			const description = document.getElementById('profileDescription').value;
			const imageFile = document.getElementById('profileImage').files[0];
			const postalCode = document.getElementById('postalCode').value;
			const prompt1 = document.getElementById('prompt1Select').value;
			const answer1 = document.getElementById('answer1Input').value;
			const prompt2 = document.getElementById('prompt2Select').value;
			const answer2 = document.getElementById('answer2Input').value;
			const gender = selectedGender; 
			
			if (!imageFile) {
				showNotification('Bitte wählen Sie ein Profilbild aus!', 'error');
				return;
			}

			if (!age || age < 18 || age > 99) {
				showNotification('Bitte geben Sie ein gültiges Alter ein (18-99)!', 'error');
				return;
			}

			if ((prompt1 && !answer1) || (prompt2 && !answer2)) {
				showNotification('Bitte beantworte deine ausgewählten Fragen.', 'error');
				return;
			}

			let coordinates = null;
			try {
				coordinates = await getCoordinatesFromPostalCode(postalCode);
			} catch (error) {
				console.warn('GPS-Koordinaten konnten nicht ermittelt werden:', error);
			}

			const selectedGenussmittel = Array.from(document.querySelectorAll('#preferencesIcons .selected'))
				.map(el => el.dataset.value)
				.filter(val => val);

			const selectedHobbiesFromUI = Array.from(document.querySelectorAll('#hobbiesIcons .selected'))
				.map(el => el.dataset.value)
				.filter(val => val);

			const allInterests = [...selectedGenussmittel, ...selectedHobbiesFromUI];

			try {
				const profileImageUrl = await uploadImageToCloudinary(imageFile);

				const profileData = {
					userId: currentUser.uid, 
					name: name,
					age: parseInt(age),
					description: description,
					interests: allInterests,
					profileImage: profileImageUrl,
					postalCode: postalCode,
					latitude: coordinates?.lat || null,
					longitude: coordinates?.lng || null,
					prompt1: prompt1,
					answer1: answer1,
					prompt2: prompt2,
					answer2: answer2,
					gender: selectedGender // 👈 an Backend senden
				};

				console.log('📤 Sende Profil-Daten:', profileData);

				const response = await fetch('/.netlify/functions/create_profile', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(profileData)
				});

				const result = await response.json();

				if (response.ok && result.success) {
					currentProfile = {
						id: result.profileId,
						name: name,
						age: age,
						description: description,
						interests: allInterests,
						profileImage: profileImageUrl,
						latitude: coordinates?.lat,
						longitude: coordinates?.lng,
						gender: selectedGender // 👈 auch lokal speichern
					};
					localStorage.setItem('currentProfile', JSON.stringify(currentProfile));

					showNotification('✅ Profil erfolgreich erstellt!', 'success');
					checkAndRenderUI();
				} else {
					showNotification('❌ Fehler beim Speichern des Profils: ' + result.error, 'error');
				}

			} catch (error) {
				console.error('Fehler beim Erstellen des Profils:', error);
				showNotification('Ein Fehler ist aufgetreten: ' + error.message, 'error');
			}
		}


		// NEW: Function to get coordinates from postal code
		async function getCoordinatesFromPostalCode(postalCode) {
			try {
				// Using OpenStreetMap Nominatim API (free alternative to Google Maps)
				const response = await fetch(
					`https://nominatim.openstreetmap.org/search?format=json&countrycodes=de&postalcode=${postalCode}&limit=1`
				);
				
				const data = await response.json();
				
				if (data && data.length > 0) {
					return {
						lat: parseFloat(data[0].lat),
						lng: parseFloat(data[0].lon)
					};
				} else {
					throw new Error('Postleitzahl nicht gefunden');
				}
			} catch (error) {
				console.error('Geocoding Fehler:', error);
				throw error;
			}
		}

		// NEW: Function to calculate distance between two coordinates
		function calculateDistance(lat1, lon1, lat2, lon2) {
			const R = 6371; // Earth's radius in kilometers
			const dLat = (lat2 - lat1) * Math.PI / 180;
			const dLon = (lon2 - lon1) * Math.PI / 180;
			const a = 
				Math.sin(dLat/2) * Math.sin(dLat/2) +
				Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
				Math.sin(dLon/2) * Math.sin(dLon/2);
			const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
			const distance = R * c;
			return Math.round(distance);
		}

		function generateSampleProfiles() {
			sampleProfiles = [
				{
					id: 1,
					name: "Anna",
					age: 26,
					gender: "female",
					description: "Liebe Spaziergänge in der Natur und romantische Sonnenuntergänge auf Bänken 🌅 Suche jemanden für tiefe Gespräche bei einem Glas Wein.",
					image: "https://images.unsplash.com/photo-1699474072277-aeccb6e17263?q=80&w=2061&auto=format&fit=crop",
					preferences: ["wine", "Wandern", "Fotografie"],
					latitude: 49.0069 + (Math.random() - 0.5) * 0.1,
					longitude: 8.4037 + (Math.random() - 0.5) * 0.1
				},
				{
					id: 2,
					name: "Max",
					age: 29,
					gender: "male",
					description: "Entspannte Gespräche bei einem Glas Wein sind das Beste! 🍷 Musik-Liebhaber der gerne chillt und das Leben genießt.",
					image: "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=400&fit=crop&crop=face",
					preferences: ["wine", "420", "Musik"],
					latitude: 49.0069 + (Math.random() - 0.5) * 0.1,
					longitude: 8.4037 + (Math.random() - 0.5) * 0.1
				},
				{
					id: 3,
					name: "Lisa",
					age: 24,
					gender: "female",
					description: "Naturliebhaberin, die gerne neue Orte entdeckt und chillige Momente genießt 🍃 Bin immer für spontane Abenteuer zu haben!",
					image: "https://images.unsplash.com/photo-1438761681033-6461ffad8d80?w=400&h=400&fit=crop&crop=face",
					preferences: ["420", "Wandern", "Haustiere"],
					latitude: 49.0069 + (Math.random() - 0.5) * 0.1,
					longitude: 8.4037 + (Math.random() - 0.5) * 0.1
				},
				{
					id: 4,
					name: "Tom",
					age: 31,
					gender: "male",
					description: "Romantiker mit Herz für schöne Aussichten und tiefe Gespräche 💕 Kunst und Kultur sind meine Leidenschaft.",
					image: "https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=400&h=400&fit=crop&crop=face",
					preferences: ["wine", "Kunst", "Musik"],
					latitude: 49.0069 + (Math.random() - 0.5) * 0.1,
					longitude: 8.4037 + (Math.random() - 0.5) * 0.1
				},
				{
					id: 5,
					name: "Sarah",
					age: 27,
					gender: "female",
					description: "Lebenslustig und immer für Abenteuer zu haben! Lass uns die Welt entdecken 🌍 Sport, Filme und gute Vibes!",
					image: "https://images.unsplash.com/photo-1544005313-94ddf0286df2?w=400&h=400&fit=crop&crop=face",
					preferences: ["wine", "420", "Sport", "Filme"],
					latitude: 49.0069 + (Math.random() - 0.5) * 0.1,
					longitude: 8.4037 + (Math.random() - 0.5) * 0.1
				}
			];
		}

		// Swipe Functions
		function createSwipeCardFromData(profile) {
		    const cardHtml = `
		        <div class="swipe-card" data-user-id="${profile.user_id}">
		            <img src="${profile.profile_image || profile.image}" alt="${profile.profile_name || profile.name}" >
		            <div class="card-content">
		                <div>
		                    <h3 class="card-name">${profile.profile_name || profile.name}</h3>
		                    <p class="card-description">${profile.description || ''}</p>
		                </div>
		                <div class="card-preferences">
		                    ${(profile.interests || []).map(interest => `<span class="preference-icon">${emojiMap[interest] || ''}</span>`).join('')}
		                </div>
		            </div>
		        </div>
		    `;
		    return cardHtml;
		}

		function renderSwipeCards() {
			const cardStack = document.getElementById('cardStack');
			if (!cardStack) {
				console.error("cardStack Element nicht gefunden!");
				return;
			}
			
			// Reset cardStack to normal positioning for cards
			cardStack.style.cssText = '';
			cardStack.innerHTML = '';

			if (!currentProfiles || currentProfiles.length === 0) {
				showNoMoreCards();
				return;
			}

			// Erstelle die Karten, da Profile vorhanden sind
			const maxCards = Math.min(3, currentProfiles.length - currentIndex);
			for (let i = 0; i < maxCards; i++) {
				const profile = currentProfiles[currentIndex + i];
				createSwipeCard(profile, i);
			}
			
			updateFloatingButtons();
		}
		
			// Verbesserte loadSwipeCards mit Error Handling
		async function loadSwipeCards() {
			console.log('🔄 loadSwipeCards aufgerufen');
			
			let cardStack = document.getElementById('cardStack');
			if (!cardStack) {
				console.warn('⚠️ cardStack noch nicht bereit, versuche erneut...');
				setTimeout(loadSwipeCards, 100);
				return;
			}

			cardStack.innerHTML = '<div class="text-center p-8"><div class="text-4xl mb-4">🔄</div><p>Lade Profile...</p></div>';
			
			try {
				const response = await fetch('/.netlify/functions/get_profile', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});
				const result = await response.json();

				if (result.success && result.data && result.data.profiles) {
					currentProfiles = result.data.profiles.filter(p => p.user_id !== currentUser.uid);
					currentIndex = 0;
					
					console.log(`🎯 ${currentProfiles.length} Profile geladen`);
					
					if (currentProfiles.length > 0) {
						requestAnimationFrame(() => renderSwipeCards());
					} else {
						// Diese Anzeige kommt, wenn die API-Verbindung erfolgreich war,
						// aber keine Profile geladen wurden.
						cardStack.innerHTML = `
							<div class="text-center p-12 flex flex-col items-center justify-center h-full">
								<div class="text-6xl mb-4">😞</div>
								<h3 class="text-xl font-bold text-gray-700 mb-2">Laden fehlgeschlagen</h3>
								<p class="text-gray-500 mb-6">Profile konnten nicht geladen werden.</p>
								<button onclick="loadSwipeCards()" class="bg-blue-500 text-white px-6 py-3 rounded-full hover:bg-blue-600">
									🔄 Erneut versuchen
								</button>
							</div>
						`;
					}
				} else {
					// Dies ist der Block für einen echten Fehler von der API.
					// Er zeigt die gleiche Anzeige, wie du es wolltest.
					cardStack.innerHTML = `
						<div class="text-center p-12 flex flex-col items-center justify-center h-full">
							<div class="text-6xl mb-4">😞</div>
							<h3 class="text-xl font-bold text-gray-700 mb-2">Laden fehlgeschlagen</h3>
							<p class="text-gray-500 mb-6">Profile konnten nicht geladen werden.</p>
							<button onclick="loadSwipeCards()" class="bg-blue-500 text-white px-6 py-3 rounded-full hover:bg-blue-600">
								🔄 Erneut versuchen
							</button>
						</div>
					`;
				}
			} catch (error) {
				console.error('Fehler beim Laden der Profile:', error);
				// Dies ist der Block für einen echten Netzwerkfehler.
				// Er zeigt auch die gleiche Anzeige, wie du es wolltest.
				cardStack.innerHTML = `
					<div class="text-center p-12 flex flex-col items-center justify-center h-full">
						<div class="text-6xl mb-4">😞</div>
						<h3 class="text-xl font-bold text-gray-700 mb-2">Laden fehlgeschlagen</h3>
						<p class="text-gray-500 mb-6">Ein Verbindungsfehler ist aufgetreten.</p>
						<button onclick="loadSwipeCards()" class="bg-blue-500 text-white px-6 py-3 rounded-full hover:bg-blue-600">
							🔄 Erneut versuchen
						</button>
					</div>
				`;
			}
		}

		function createSwipeCard(profile, stackIndex) {
			const cardStack = document.getElementById('cardStack');
			
			const card = document.createElement('div');
			card.className = 'swipe-card';
			card.style.zIndex = 10 - stackIndex;
			card.style.transform = `scale(${1 - stackIndex * 0.03}) translateY(${stackIndex * 4}px)`;
			card.dataset.userId = profile.user_id;
			card.dataset.stackIndex = stackIndex;
			
			const imageUrl = profile.profile_image;

			// Calculate distance if both profiles have coordinates
			let distanceText = '';
			if (currentProfile && currentProfile.latitude && currentProfile.longitude && 
				profile.latitude && profile.longitude) {
				const distance = calculateDistance(
					currentProfile.latitude, currentProfile.longitude,
					profile.latitude, profile.longitude
				);
				distanceText = `${distance} km entfernt`;
			} else {
				// Fallback: Generate random distance for demo purposes
				const randomDistance = Math.floor(Math.random() * 50) + 1;
				distanceText = `${randomDistance} km entfernt`;
			}

			// Format age display
			const ageDisplay = profile.age ? `, ${profile.age}` : '';
			
			// Interessen formatieren (nur die ersten 4 anzeigen)
			const interests = (profile.interests || []).slice(0, 4).map(interest => 
				`<span class="preference-icon">${emojiMap[interest] || hobbiesMap[interest] || '❓'}</span>`
			).join('');
			
			card.innerHTML = `
				<img src="${imageUrl}" 
					 alt="${profile.profile_name}" 
					 class="card-image"
				>
				<div class="card-content">
					<div class="card-header">
						<div class="card-name-age">
							<h3 class="card-name">${profile.profile_name}${ageDisplay}</h3>
						</div>
						<div class="card-distance">${distanceText}</div>
					</div>
					<p class="card-description">${profile.description || 'Keine Beschreibung verfügbar'}</p>
					<div class="card-preferences">
						${interests}
						${(profile.interests || []).length > 4 ? '<span class="more-interests">+' + ((profile.interests || []).length - 4) + '</span>' : ''}
					</div>
				</div>
			`;
			
			// Profil-Daten an Card binden
			card.__profile = profile;
			
			// Event Listeners nur für die oberste Karte
			if (stackIndex === 0) {
				setupSwipeGestures(card);
				
				// Klick für Profil-Details (nur auf Bild)
				const cardImage = card.querySelector('.card-image');
				cardImage.addEventListener('click', (e) => {
					e.stopPropagation();
					showProfileDetails(profile);
				});
			}
			
			cardStack.appendChild(card);
		}

		
		// Neue Funktion für Profil-Details
		function showProfileDetails(profile) {
		    const profileName = profile.profile_name || profile.name || "Unbekannt";
		    const profileAge = profile.age ? `, ${profile.age}` : "";
		    const profileDescription = profile.description || "Keine Beschreibung verfügbar";
		    const prefs = profile.interests || profile.preferences || [];
		    let profileImage = profile.profile_image || profile.image;
		
		    // ✅ Entfernung berechnen (falls Koordinaten verfügbar)
		    let distanceText = "";
		    if (profile.latitude && profile.longitude && currentUser?.latitude && currentUser?.longitude) {
		        const dist = calculateDistance(
		            currentUser.latitude, currentUser.longitude,
		            profile.latitude, profile.longitude
		        );
		        distanceText = `<p class="text-gray-500 text-sm mb-2">📍 ${dist} km entfernt</p>`;
		    }
		
		    // ✅ Prompts & Antworten
		    let promptsHtml = "";
		    if (profile.prompt1 && profile.answer1) {
		        promptsHtml += `
		            <div class="mb-4">
		                <h4 class="text-md font-semibold text-gray-700 mb-1">${profile.prompt1}</h4>
		                <p class="text-gray-600">${profile.answer1}</p>
		            </div>`;
		    }
		    if (profile.prompt2 && profile.answer2) {
		        promptsHtml += `
		            <div class="mb-4">
		                <h4 class="text-md font-semibold text-gray-700 mb-1">${profile.prompt2}</h4>
		                <p class="text-gray-600">${profile.answer2}</p>
		            </div>`;
		    }
		
		    // ✅ Interessen rendern
		    const preferencesHtml = prefs.map(pref => {
		        const emoji = emojiMap[pref] || hobbiesMap[pref] || '❓';
		        return `<span class="inline-block m-1 px-3 py-1 bg-gray-100 rounded-full text-sm font-medium">${emoji} ${pref}</span>`;
		    }).join('');
		
		    // ✅ Gesamtes Modal
		    const detailsHtml = `
		        <div class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4" 
		             onclick="closeProfileModal()">
		            <div class="bg-white rounded-2xl max-w-md w-full max-h-90vh overflow-y-auto" 
		                 onclick="event.stopPropagation()">
		                <div class="relative">
		                    <img src="${profileImage}" 
		                         alt="${profileName}" 
		                         class="w-full h-64 object-cover rounded-t-2xl"
		                         onerror="this.src='${profileImage}'">
		                    <button onclick="closeProfileModal()" 
		                            class="absolute top-4 right-4 w-8 h-8 bg-black bg-opacity-50 text-white rounded-full flex items-center justify-center hover:bg-opacity-70">
		                        ✕
		                    </button>
		                </div>
		                <div class="p-6">
		                    <h2 class="text-2xl font-bold text-gray-800 mb-1">${profileName}${profileAge}</h2>
		                    ${distanceText}
		                    <p class="text-gray-600 mb-4 leading-relaxed">${profileDescription}</p>
		
		                    ${prefs.length > 0 ? `
		                        <div class="mb-6">
		                            <h4 class="text-lg font-semibold text-gray-700 mb-2">Interessen</h4>
		                            <div class="flex flex-wrap">
		                                ${preferencesHtml}
		                            </div>
		                        </div>
		                    ` : ''}
		
		                    ${promptsHtml}
		
		                    <div class="flex space-x-3">
		                        <button onclick="swipeCard('left'); closeProfileModal();" 
		                                class="flex-1 bg-gradient-to-r from-red-500 to-red-600 text-white py-3 px-6 rounded-full hover:from-red-600 hover:to-red-700 transition-colors font-semibold">
		                            ❌ Nein
		                        </button>
		                        <button onclick="swipeCard('right'); closeProfileModal();" 
		                                class="flex-1 bg-gradient-to-r from-green-500 to-green-600 text-white py-3 px-6 rounded-full hover:from-green-600 hover:to-green-700 transition-colors font-semibold">
		                            💖 Ja
		                        </button>
		                    </div>
		                </div>
		            </div>
		        </div>
		    `;
		    
		    // Entferne vorherige Modals
		    const existingModal = document.querySelector('[data-profile-modal]');
		    if (existingModal) {
		        existingModal.remove();
		    }
		    
		    const modalDiv = document.createElement('div');
		    modalDiv.setAttribute('data-profile-modal', 'true');
		    modalDiv.innerHTML = detailsHtml;
		    document.body.appendChild(modalDiv);
		}
		
		// Event Listeners für Keyboard Shortcuts (aktualisiert)
		document.addEventListener('keydown', (e) => {
		    // Escape für Modals
		    if (e.key === 'Escape') {
		        closeLogin();
		        closeProfileModal();
		        closeProfilePopup();
		        if (sidebarOpen) closeSidebar();
		    }
		    
		    // Swipe shortcuts nur wenn Swipe-Container sichtbar
		    const swipeContainer = document.getElementById('swipeContainer');
		    if (swipeContainer && swipeContainer.style.display === 'block') {
		        if (e.key === 'ArrowLeft') {
		            e.preventDefault();
		            swipeCard('left');
		        }
		        if (e.key === 'ArrowRight') {
		            e.preventDefault();
		            swipeCard('right');
		        }
		            
		        }
		    
		});
		
		function closeProfileModal() {
		    const modal = document.querySelector('[data-profile-modal]');
		    if (modal) {
		        modal.remove();
		    }
		}

		function shuffle(array) {
			return array.sort(() => Math.random() - 0.5);
		}

		     // Swipe Gesten Setup
		function setupSwipeGestures(card) {
		    let startX = 0, startY = 0;
		    let currentX = 0, currentY = 0;
		    let isDragging = false;
		    
		    // Mouse Events
		    card.addEventListener('mousedown', handleStart);
		    document.addEventListener('mousemove', handleMove);
		    document.addEventListener('mouseup', handleEnd);
		    
		    // Touch Events
		    card.addEventListener('touchstart', handleStart, { passive: true });
		    document.addEventListener('touchmove', handleMove, { passive: false });
		    document.addEventListener('touchend', handleEnd);
		            function startDrag(e) {
		                if (card !== document.querySelector('.swipe-card:last-child')) return;
		                
		                cardBeingDragged = true;
		                card.classList.add('dragging');
		                
		                startX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
		                
		                document.addEventListener('mousemove', drag);
		                document.addEventListener('touchmove', drag);
		                document.addEventListener('mouseup', endDrag);
		                document.addEventListener('touchend', endDrag);
		            }

		    function handleStart(e) {
		        if (isSwipeInProgress) return;
		        
		        const clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
		        const clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
		        
		        startX = clientX;
		        startY = clientY;
		        isDragging = true;
		        
		        card.style.transition = '';
		        card.style.cursor = 'grabbing';
		    }
		    
		    function handleMove(e) {
		        if (!isDragging || isSwipeInProgress) return;
		        
		        e.preventDefault();
		        
		        const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
		        const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
		        
		        currentX = clientX - startX;
		        currentY = clientY - startY;
		        
		        // Rotation und Opacity basierend auf X-Position
		        const rotation = currentX * 0.1;
		        const opacity = Math.max(0.3, 1 - Math.abs(currentX) / 300);
		        
		        card.style.transform = `translateX(${currentX}px) translateY(${currentY}px) rotate(${rotation}deg)`;
		        card.style.opacity = opacity;
		        
		        // Visuelle Hinweise
		        if (Math.abs(currentX) > 50) {
		            card.style.boxShadow = currentX > 0 ? 
		                '0 0 20px rgba(76, 175, 80, 0.5)' : 
		                '0 0 20px rgba(255, 107, 107, 0.5)';
		        }
		    }
		    
		    function handleEnd(e) {
		        if (!isDragging) return;
		        
		        isDragging = false;
		        card.style.cursor = 'grab';
		        card.style.boxShadow = '';
		        
		        // Entscheidung basierend auf Swipe-Distanz
		        if (Math.abs(currentX) > 100) {
		            const direction = currentX > 0 ? 'right' : 'left';
		            completeSwipe(direction);
		        } else {
		            // Zurück zur ursprünglichen Position
		            card.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
		            card.style.transform = '';
		            card.style.opacity = '';
		        }
		        
		        currentX = 0;
		        currentY = 0;
		    }
		}	

		function drag(e) {
			if (!cardBeingDragged) return;
			
			e.preventDefault();
			currentX = (e.type === 'mousemove' ? e.clientX : e.touches[0].clientX) - startX;
			
			const rotation = currentX * 0.1;
			const opacity = 1 - Math.abs(currentX) / 300;
			
			card.style.transform = `translateX(${currentX}px) rotate(${rotation}deg)`;
			card.style.opacity = opacity;
		}

		function endDrag() {
			if (!cardBeingDragged) return;
			
			cardBeingDragged = false;
			card.classList.remove('dragging');
			
			document.removeEventListener('mousemove', drag);
			document.removeEventListener('touchmove', drag);
			document.removeEventListener('mouseup', endDrag);
			document.removeEventListener('touchend', endDrag);

			if (Math.abs(currentX) > 100) {
				const direction = currentX > 0 ? 'right' : 'left';
				completeSwipe(card, profile, direction);
			} else {
				// Snap back
				card.style.transform = '';
				card.style.opacity = '';
			}
			
			currentX = 0;
		}

		// Funktion zum Anzeigen des nächsten Profils
		function showNextCard() {
			if (currentIndex < currentProfiles.length) {
				currentSwipeUser = currentProfiles[currentIndex];
				const swipeContainer = document.getElementById('swipeContainer');
				
				// Lösche alte Karten, um nur eine anzuzeigen
				swipeContainer.innerHTML = '';
				
				// Erstelle eine neue Karte
				const card = document.createElement('div');
				card.className = 'swipe-card bg-white rounded-lg shadow-lg p-6 w-full max-w-sm transition-all duration-300 transform';
				card.innerHTML = `
					<img src="${currentSwipeUser.profile_image}" alt="Profilbild von ${currentSwipeUser.name}" class="rounded-lg mb-4 w-full h-auto">
					<h3 class="text-xl font-bold">${currentSwipeUser.name}</h3>
					<p class="text-gray-600 mt-2">${currentSwipeUser.description}</p>
				`;
				swipeContainer.appendChild(card);
				
				currentIndex++;
			} else {
				// Keine Profile mehr zum Anzeigen, zeige eine entsprechende Nachricht
				const swipeContainer = document.getElementById('swipeContainer');
				swipeContainer.innerHTML = `
					<div class="text-center p-8 text-gray-500">
						<p>Das war's für heute! Schau später wieder vorbei, vielleicht gibt es neue Leute in deiner Nähe.</p>
					</div>
				`;
			}
		}

		// Swipe über Buttons
		function swipeCard(direction) {
		    if (isSwipeInProgress) return;
		    
		    const activeCard = document.querySelector('.swipe-card[data-stack-index="0"]');
		    if (!activeCard) {
		        console.log('Keine aktive Karte gefunden');
		        return;
		    }
		    
		    completeSwipe(direction);
		}


		function nextProfileFromDeck() {
		  // einfache Nachlade-Strategie: nimm das nächste Profil, wenn vorhanden
		  const next = currentProfiles[currentCardIndex + 2];
		  currentCardIndex++;
		  return next;
		}
		
		async function handleSwipe(profile, isLike) {
		    if (!isLike) return; // Nur bei Likes weiter
		    
		    try {
		        const likerId = currentUser.uid;
		        // Prüfe ob es ein DB-Profil oder Sample-Profil ist
		        const likedId = profile.user_id || profile.id; // DB hat user_id, Samples haben id
		        
		        if (!likedId || typeof likedId !== 'number') {
		            // Sample-Profile -> lokale Match-Simulation
		            showNotification(`💖 Match mit ${profile.name || profile.profile_name}!`, 'success');
		            return;
		        }
		        
		        // Echtes DB-Profil -> API-Aufruf
		        const response = await fetch('/.netlify/functions/create_match', {
		            method: 'POST',
		            headers: { 'Content-Type': 'application/json' },
		            body: JSON.stringify({ 
		                likerId: likerId,
		                likedId: likedId 
		            })
		        });
		
		        const result = await response.json();
		        		        
		    } catch (error) {
		        console.error('Fehler beim Erstellen des Matches:', error);
		        // Zeige trotzdem positive Nachricht
		        showNotification(`💖 Match mit ${profile.profile_name || profile.name}!`, 'success');
		    }
		}


		async function loadMessages() {
			const container = document.getElementById('chatMessages');
			const suggestionsContainer = document.getElementById('aiSuggestionsContainer');

			if (!container || !chatState.currentMatchId || !suggestionsContainer) {
				console.error("❌ Missing required elements or no active chat");
				return;
			}

			// Check if this is an AI chat - if so, redirect to AI function
			const isAIChat = chatState.isAI;
			if (isAIChat) {
				loadAIMessages();
				return;
			}

			try {
				// Ensure match_id is a number for real chats
				const match_id = parseInt(chatState.currentMatchId);
				if (isNaN(match_id) || match_id <= 0) {
					console.error('❌ Invalid match ID for real chat:', chatState.currentMatchId);
					container.innerHTML = `
						<div class="text-center text-red-500 py-8">
							<p>Fehlerhafte Chat-ID</p>
						</div>
					`;
					return;
				}

				const response = await fetch('/.netlify/functions/get_messages', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ match_id })
				});

				const result = await response.json();

				if (response.ok && result.success) {
					const currentMessageCount = result.messages ? result.messages.length : 0;
					const hasNewMessages = currentMessageCount > chatState.lastLoadedMessageCount;
					const isChatEmpty = currentMessageCount === 0;

					if (hasNewMessages || isChatEmpty) {
						container.innerHTML = '';
						
						if (result.messages && result.messages.length > 0) {
							result.messages.forEach(message => {
								const messageClass = message.sender_id === parseInt(currentUser.uid) ? 'sent' : 'received';
								const messageBubble = document.createElement('div');
								messageBubble.classList.add('message', messageClass);
								
								const timestamp = new Date(message.sent_at).toLocaleTimeString('de-DE', { 
									hour: '2-digit', 
									minute: '2-digit' 
								});
								
								messageBubble.innerHTML = `
									<div class="message-bubble">${escapeHtml(message.message_text)}</div>
									<div class="text-xs opacity-50 mt-1">${timestamp}</div>
								`;
								container.appendChild(messageBubble);
							});
						} else {
							container.innerHTML = `
								<div class="text-center text-gray-500 py-8">
									<div class="text-4xl mb-2">👋</div>
									<p>Schreibt euch eure erste Nachricht!</p>
								</div>
							`;
						}
						
						container.scrollTop = container.scrollHeight;
					}

					// AI suggestions logic for real chats only
					const lastMessage = result.messages[result.messages.length - 1];
					const lastMessageIsFromPartner = lastMessage && lastMessage.sender_id !== parseInt(currentUser.uid);
					
					if ((isChatEmpty && !chatState.aiSuggestionsLoaded) || (hasNewMessages && lastMessageIsFromPartner)) {
						chatState.aiSuggestionsLoaded = true;
						updateSuggestions();
					} else if (!isChatEmpty && !lastMessageIsFromPartner && !hasNewMessages) {
						suggestionsContainer.classList.add('hidden');
					}

					chatState.lastLoadedMessageCount = currentMessageCount;

				} else {
					console.error('❌ Error loading messages:', result.error);
					if (container.children.length === 0) {
						container.innerHTML = `
							<div class="text-center text-red-500 py-8">
								<p>Nachrichten konnten nicht geladen werden</p>
								<button onclick="loadMessages()" class="mt-2 px-4 py-2 bg-blue-500 text-white rounded">
									🔄 Erneut versuchen
								</button>
							</div>
						`;
					}
				}
			} catch (error) {
				console.error('❌ Network error loading messages:', error);
				if (container.children.length === 0) {
					container.innerHTML = `
						<div class="text-center text-red-500 py-8">
							<p>Verbindungsfehler</p>
							<button onclick="loadMessages()" class="mt-2 px-4 py-2 bg-blue-500 text-white rounded">
								🔄 Erneut versuchen
							</button>
						</div>
					`;
				}
			}
		}
		
		async function sendMessage() {
			const messageInput = document.getElementById('messageInput');
			const messageText = messageInput.value.trim();
			
			if (!messageText || !chatState.currentMatchId || !currentUser.uid) {
				
				
				return;
			}
			
			// Check if this is an AI chat
			const isAIChat = chatState.isAI;
			
			// Optimistic update: Show message immediately
			const chatMessages = document.getElementById('chatMessages');
			const messageElement = document.createElement('div');
			messageElement.classList.add('message', 'sent');
			messageElement.innerHTML = `<div class="message-bubble">${escapeHtml(messageText)}</div>`;
			chatMessages.appendChild(messageElement);
			chatMessages.scrollTop = chatMessages.scrollHeight;

			// Clear and disable input
			const originalValue = messageText;
			messageInput.value = '';
			messageInput.disabled = true;

			// Handle real user chat
			console.log("Sending message:", {
			    match_id: parseInt(chatState.currentMatchId),
			    sender_id: parseInt(currentUser.uid),
			    message_text: originalValue
			});	
			console.log("Types:", {
			    match_id: typeof parseInt(chatState.currentMatchId),
			    sender_id: typeof parseInt(currentUser.uid),
			    message_text: typeof originalValue
			});
			try {
				if (isAIChat) {
					// Handle AI chat - KEINE Erfolgsmeldung
					sendAIMessage(originalValue);
				} else {
					// Handle real user chat
					const response = await fetch('/.netlify/functions/send_message', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							match_id: parseInt(chatState.currentMatchId),
							sender_id: parseInt(currentUser.uid),
							message_text: originalValue
						})
					});

					const result = await response.json();
					
					if (response.ok && result.success) {
						// Reset AI suggestions flag so they can load on partner's response
						chatState.aiSuggestionsLoaded = false;
						// ❌ ENTFERNT: showNotification('Nachricht gesendet!', 'success');
						
						// Force reload messages to ensure synchronization
						setTimeout(() => loadMessages(), 100);
					} else {
						console.error('Server error:', result);
						showNotification('Nachricht konnte nicht gesendet werden: ' + (result.error || 'Unbekannter Fehler'), 'error');
						chatMessages.removeChild(messageElement);
						messageInput.value = originalValue;
					}
				}
			} catch (error) {
				console.error('Network error:', error);
				showNotification('Verbindungsfehler beim Senden', 'error');
				chatMessages.removeChild(messageElement);
				messageInput.value = originalValue;
			} finally {
				messageInput.disabled = false;
				messageInput.focus();
			}
		}


		function setupMessageInput() {
			const messageInput = document.getElementById('messageInput');
			if (messageInput) {
				// Remove any existing event listeners
				messageInput.replaceWith(messageInput.cloneNode(true));
				const newInput = document.getElementById('messageInput');
				
				newInput.addEventListener('keydown', (e) => {
					if (e.key === 'Enter') {
						e.preventDefault();
						sendMessage();
					}
				});
				newInput.focus();
			}
		}
		
		async function reportChat(match) {
			// Wenn kein Match übergeben wird, automatisch das aktuelle Profil nehmen
			// Für AI-Matches z.B. das gerade angezeigte Profil im Swipe
			match = match || currentProfiles?.[currentIndex] || chatState.currentMatch;

			// AI-Match: nur Illusion, kein Zugriff auf IDs nötig
			if (match?.isAI) {
				if (!confirm('Sind Sie sicher, dass Sie diesen Chat melden möchten?')) return;
				alert('Chat mit AI gemeldet. Vielen Dank für Ihr Feedback.');
				closeChat();
				return;
			}

			// Echte Matches prüfen
			if (!match?.match_id || !currentUser?.uid) {
				alert('Fehler: Chat oder Benutzer nicht identifiziert.');
				return;
			}

			if (!confirm('Sind Sie sicher, dass Sie diesen Chat melden möchten?')) return;

			try {
				const response = await fetch('/.netlify/functions/report_chat', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						match_id: parseInt(match.match_id),
						reporter_id: currentUser.uid
					}),
				});

				const result = await response.json();
				if (response.ok && result.success) {
					alert('Chat erfolgreich gemeldet. Vielen Dank für Ihr Feedback.');
					closeChat();
				} else {
					alert('Fehler beim Melden des Chats: ' + (result.error || 'Unbekannter Fehler.'));
				}
			} catch (error) {
				console.error('❌ Error reporting chat:', error);
				alert('Ein Netzwerkfehler ist aufgetreten.');
			}
		}



		async function updateSuggestions() {
			if (!chatState.currentMatchId || !currentUser) {
				document.getElementById('aiSuggestionsContainer').classList.add('hidden');
				return;
			}

			const mainContainer = document.getElementById('aiSuggestionsContainer');
			const thinkingBubble = document.getElementById('aiThinkingBubble');
			const typingTextElement = document.getElementById('typingText');

			// Check if this is an AI chat - if so, don't show suggestions
			const isAIChat = typeof chatState.currentMatchId === 'string' && chatState.currentMatchId.toString().includes('ai_match_');
			if (isAIChat) {
				mainContainer.classList.add('hidden');
				return;
			}

			// Only show suggestions for real user chats
			mainContainer.classList.remove('hidden');
			thinkingBubble.classList.remove('hidden');
			typingTextElement.textContent = 'One-KI denkt nach...';
			
			// Remove old suggestion buttons
			const oldButtons = mainContainer.querySelectorAll('button');
			oldButtons.forEach(button => button.remove());

			try {
				// Make sure matchId is a number for real chats
				const matchId = parseInt(chatState.currentMatchId);
				if (isNaN(matchId)) {
					console.error('❌ Invalid match ID for suggestions:', chatState.currentMatchId);
					mainContainer.classList.add('hidden');
					return;
				}

				const response = await fetch('/.netlify/functions/get_chat_suggestions', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ 
						matchId: matchId,  // Send as number
						currentUserId: currentUser.uid 
					}),
				});

				const result = await response.json();
				
				// Animation timeout
				setTimeout(() => {
					thinkingBubble.classList.add('hidden');

					if (result.success && result.suggestions.length > 0) {
						result.suggestions.forEach(suggestion => {
							const button = document.createElement('button');
							button.onclick = () => {
								document.getElementById('messageInput').value = suggestion;
								logSuggestionClick(suggestion);
							};

							const innerDiv = document.createElement('div');
							innerDiv.className = 'ki-beta-container';
							
							const innerSpan = document.createElement('span');
							innerSpan.className = 'ki-beta-branding';
							innerSpan.textContent = suggestion;

							innerDiv.appendChild(innerSpan);
							button.appendChild(innerDiv);
							mainContainer.appendChild(button);
						});
					} else {
						mainContainer.classList.add('hidden');
					}
				}, 2500);

			} catch (error) {
				console.error('❌ Error loading AI suggestions:', error);
				thinkingBubble.classList.add('hidden');
				mainContainer.classList.add('hidden');
			}
		}

		
		async function logSuggestionClick(suggestionText) {
			try {
				await fetch('/.netlify/functions/log_suggestion_click', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						userId: currentUser.uid,
						clickedSuggestion: suggestionText
					}),
				});
			} catch (error) {
				console.error('❌ Error logging suggestion click:', error);
			}
		}
		
		async function openMatchChat(matchId, matchUserId, matchName, matchImage) {
		  console.log('🔥 Opening chat - Match ID:', matchId, 'User ID:', matchUserId);
		  closeChat();
		  
		  if (!matchId || matchUserId === undefined || !matchName) {
			console.error('❌ Missing required chat parameters');
			showNotification('❌ Fehlerhafte Chat-Daten', 'error');
			return;
		  }
		  
		  // Determine if this is an AI chat based on matchUserId being 0
		  const isAIChat = Number(matchUserId) === 0;
		  
		  // Ensure matchId is a number for database operations
		  const numericMatchId = parseInt(matchId);
		  if (isNaN(numericMatchId) || numericMatchId <= 0) {
			console.error('❌ Invalid match ID:', matchId);
			showNotification('❌ Fehlerhafte Match-ID', 'error');
			return;
		  }
		  
		  chatState = {
			currentMatchId: numericMatchId,          // Always use numeric match ID
			currentConversationId: numericMatchId,   // Always use numeric match ID
			aiSuggestionsLoaded: false,
			lastLoadedMessageCount: 0,
			messageInterval: null,
			isAI: isAIChat                           // Flag to identify AI chats
		  };

			// Chat Modal erzeugen...
			const chatModalHtml = `
				<div class="fixed inset-0 bg-black bg-opacity-50 z-[2001] flex items-center justify-center p-4" data-chat-modal>
					<div class="bg-white rounded-2xl max-w-md w-full h-[90vh] flex flex-col" onclick="event.stopPropagation()">
						<div class="bg-gray-100 p-4 flex items-center rounded-t-2xl shadow-sm">
							<img src="${matchImage || '/default-avatar.png'}" alt="${matchName}" class="w-10 h-10 rounded-full mr-3">
							<h3 class="text-lg font-bold flex-grow">${matchName}</h3>
							<div class="flex items-center space-x-2">
								${isAIChat ? `<div class="ki-beta-container relative overflow-hidden mr-2"><span class="ki-beta-branding">One-KI Beta</span></div>` : ''}
								<button onclick="reportChat()" class="text-gray-500 hover:text-red-500">
									<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
								</button>
								<button onclick="closeChat()" class="text-gray-500 hover:text-gray-700">
									<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
								</button>
							</div>
						</div>
						<div id="chatMessages" class="flex-grow p-4 overflow-y-auto space-y-2"></div>
						<div id="aiSuggestionsContainer" class="p-2 flex flex-wrap gap-2 justify-center border-t border-gray-200 hidden">
							<div id="aiThinkingBubble" class="ki-beta-container hidden">
								<span id="typingText" class="ki-beta-branding typing-animation"></span>
							</div>
						</div>
						<div class="p-4 bg-gray-100 rounded-b-2xl flex items-center">
							<input type="text" id="messageInput" placeholder="Nachricht senden..." class="flex-grow rounded-full py-2 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500" maxlength="500">
							<button onclick="sendMessage()" class="bg-blue-500 text-white rounded-full p-2 ml-2 hover:bg-blue-600">
								<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
							</button>
						</div>
					</div>
				</div>
			`;
			const chatDiv = document.createElement('div');
			chatDiv.innerHTML = chatModalHtml;
			document.body.appendChild(chatDiv);

			setupMessageInput();
			markMessagesAsRead(matchId);

			if (isAIChat) {
				loadAIMessages();
			} else {
				loadMessages();
				chatState.messageInterval = setInterval(loadMessages, 3000);
			}
		}
		
		function closeChat() {
			const chatModal = document.querySelector('[data-chat-modal]');
			if (chatModal) {
				chatModal.remove();
			}
			
			// Clear polling interval
			if (chatState.messageInterval) {
				clearInterval(chatState.messageInterval);
			}
			
			// Reset chat state completely
			chatState = {
				currentMatchId: null,
				currentConversationId: null,
				aiSuggestionsLoaded: false,
				lastLoadedMessageCount: 0,
				messageInterval: null
			};
			
			const matchesList = document.getElementById('matchesList');
			if (matchesList && matchesList.offsetParent !== null) {
				loadUserMatches(true); // force refresh nach Chat
			}
		}
		
		function loadAIMessages() {
			const container = document.getElementById('chatMessages');
			if (!container || !chatState.currentMatchId) return;

			let aiMessages = JSON.parse(localStorage.getItem(`ai_chat_${chatState.currentMatchId}`) || '[]');
			container.innerHTML = '';

			if (aiMessages.length === 0) {
				container.innerHTML = `<div class="text-center text-gray-500 py-8">
					<div class="text-4xl mb-2">👋</div>
					<p>Schreibt euch eure erste Nachricht!</p>
				</div>`;
				return;
			}

			aiMessages.forEach(msg => {
				const messageClass = msg.sender === 'user' ? 'sent' : 'received';
				const bubble = document.createElement('div');
				bubble.classList.add('message', messageClass);
				const timestamp = new Date(msg.timestamp).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
				bubble.innerHTML = `<div class="message-bubble">${escapeHtml(msg.text)}</div><div class="text-xs opacity-50 mt-1">${timestamp}</div>`;
				container.appendChild(bubble);
			});

			container.scrollTop = container.scrollHeight;
		}

		async function saveAIMessage(sender, text) {
		  const matchId = chatState.currentMatchId; // This is now the real database match ID
		  
		  if (!matchId) {
			console.warn('Keine Match-ID gefunden');
			return;
		  }
		  
		  // Store in localStorage using the real match ID
		  let aiMessages = JSON.parse(localStorage.getItem(`ai_chat_${matchId}`) || '[]');
		  aiMessages.push({
			sender: sender,
			text: text,
			timestamp: new Date().toISOString()
		  });
		  localStorage.setItem(`ai_chat_${matchId}`, JSON.stringify(aiMessages));
		  
		  // Store in database using the real match ID
		  const dbSenderId = sender === 'user' ? parseInt(currentUser.uid) : 0;
		  
		  try {
			await fetch('/.netlify/functions/send_message', {
			  method: 'POST',
			  headers: { 'Content-Type': 'application/json' },
			  body: JSON.stringify({
				match_id: matchId,        // Real database match ID
				sender_id: dbSenderId,    // 0 for AI, real user ID for user
				message_text: text,
				is_ai: sender === 'ai'
			  })
			});
		  } catch (err) {
			console.error('❌ Fehler beim Speichern der AI-Nachricht in DB', err);
		  }
		}

		async function sendAIMessage(messageText) {
		    console.log("sendAIMessage called with:", messageText);
			console.log("chatState.currentMatchId:", chatState.currentMatchId);
			if (!chatState.currentMatchId || !messageText) return;

			await saveAIMessage('user', messageText); // speichert lokal + DB
			loadAIMessages();

			const convId = chatState.currentMatchId;
			if (!window.aiReplyTimers) window.aiReplyTimers = {};
			if (!window.aiReplyTimers[convId]) window.aiReplyTimers[convId] = { pendingUserMessages: [] };
			window.aiReplyTimers[convId].pendingUserMessages.push({ text: messageText, ts: Date.now() });

			const delay = Math.floor(Math.random() * (60_000 - 8_000)) + 8_000; // 8–60 Sek
			window.aiReplyTimers[convId].dueAt = Date.now() + delay;
			window.aiReplyTimers[convId].id = setTimeout(() => triggerAiReply(convId), delay);

			console.log(`⏱️ [${convId}] AI antwortet in ${Math.round(delay / 1000)}s`);
		}

		console.log('currentMatchId:', chatState.currentMatchId);
		const localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
		console.log('localMatches:', localMatches);
	
	async function triggerAiReply(convId) {
			const t = window.aiReplyTimers[convId];
			if (!t) return;

			const combinedUserText = (t.pendingUserMessages || []).map(m => m.text).join("\n");
			t.pendingUserMessages = [];

			try {
				// KORRIGIERT: Hole AI-Profile-ID aus localStorage
				const localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
				const currentMatch = localMatches.find(m => m.match_id === convId);
				const aiProfileId = currentMatch?.ai_profile_id || 1; // Fallback auf AI-ID 1

				const response = await fetch('/.netlify/functions/ai-chat', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						aiProfileId,
						userMessage: combinedUserText,
						userProfile: {
							id: currentUser?.uid || "guest",
							name: currentUser?.email || null,
							interests: currentProfile?.interests || []
						},
						conversationId: convId
					})
				});
				
				const result = await response.json();
				const aiText = result.success ? result.response : "Entschuldige, gerade nicht verfügbar.";

				// Speichern + Laden
				await saveAIMessage('ai', aiText);
				if (chatState.currentMatchId === convId) loadAIMessages();

			} catch (err) {
				console.error('AI reply failed', err);
				await saveAIMessage('ai', "Ups, da ist etwas schiefgelaufen!");
				if (chatState.currentMatchId === convId) loadAIMessages();
			} finally {
				if (window.aiReplyTimers[convId]?.id) clearTimeout(window.aiReplyTimers[convId].id);
				delete window.aiReplyTimers[convId];
			}
		}
						
		// Swipe abschließen
		async function completeSwipe(direction) {
			if (isSwipeInProgress) return;
			
			isSwipeInProgress = true;
			
			const activeCard = document.querySelector('.swipe-card[data-stack-index="0"]');
			if (!activeCard || !activeCard.__profile) {
				isSwipeInProgress = false;
				return;
			}
			
			const profile = activeCard.__profile;
			const isLike = direction === 'right';
			
			// 🔥 Speichern für SwipeBack
			lastSwipedProfile = profile;			
					
			// Animation
			activeCard.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
			const moveX = direction === 'right' ? 400 : -400;
			const rotation = direction === 'right' ? 30 : -30;
			
			activeCard.style.transform = `translateX(${moveX}px) rotate(${rotation}deg)`;
			activeCard.style.opacity = '0';
			
			    
			// 🔥 Swipe in DB speichern (nur echte Profile)
			if (!profile.isAI) {
				try {
					await fetch('/.netlify/functions/record_swipe', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							userId: currentUser.uid,
							swipedUserId: profile.user_id,
							direction: direction
						})
					});
				} catch (error) {
					console.error('Fehler beim Aufzeichnen des Swipes:', error);
				}
			}
			
			// Like/Dislike verarbeiten
			if (isLike) {
				await handleLike(profile);
			}
			
			// Karte nach Animation entfernen
			setTimeout(() => {
				activeCard.remove();
				currentIndex++;
				
				// Verbleibende Karten neu positionieren
				updateCardStack();
				
				// Neue Karte laden falls verfügbar
				if (currentIndex + 2 < currentProfiles.length) {
					const newProfile = currentProfiles[currentIndex + 2];
					createSwipeCard(newProfile, 2);
				}
				
				// ✅ FIX: Check if no more cards and call the unified function
				if (currentIndex >= currentProfiles.length) {
					setTimeout(() => {
						showNoMoreProfilesInCardStack();
					}, 500);
				}
				
				isSwipeInProgress = false;
			}, 300);
		}

		function updateCardStack() {
			const cards = document.querySelectorAll('.swipe-card');
			cards.forEach((card, index) => {
				card.dataset.stackIndex = index;
				card.style.zIndex = 10 - index;
				card.style.transform = `scale(${1 - index * 0.03}) translateY(${index * 4}px)`;
				
				// Event Listeners nur für die neue oberste Karte
				if (index === 0 && !card.hasAttribute('data-gestures-setup')) {
					setupSwipeGestures(card);
					card.setAttribute('data-gestures-setup', 'true');
					
					// Klick für Profil-Details - auf der gesamten Karte
					card.addEventListener('click', (e) => {
						e.stopPropagation();
						// Verhindert das Öffnen des Popups, wenn der Swipe-Aktions-Bereich geklickt wird
						if (e.target.closest('.swipe-actions')) {
							return;
						}
						showProfileDetails(card.__profile);
					});
				}
			});
		}

		async function handleLike(profile) {
			try {
				console.log('💖 Like für:', profile.profile_name || profile.name);

				const isAIMatch = profile.isAI || typeof profile.user_id === 'string';

				// --- Prüfen, ob Match lokal schon existiert ---
				let localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
				if (
					localMatches.some(m => (isAIMatch ? m.ai_profile_id === profile.id : m.matched_user_id === profile.user_id))
				) {
					console.log('ℹ️ Match existiert bereits lokal, kein Request nötig');
					return;
				}

				if (isAIMatch) {
					if (!profile.id) throw new Error('AI Profile ID fehlt!');

					await fetch('/.netlify/functions/ensure_ai_dummy', { method: 'POST' });

					const response = await fetch('/.netlify/functions/create_match', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							likerId: parseInt(currentUser.uid),
							likedId: 0,
							aiProfileId: profile.id
						})
					});

					const result = await response.json();
					if (!result.success) throw new Error(result.error || 'Failed to create AI match');

					const realMatchId = result.matchId;

					const aiMatch = {
						id: realMatchId,
						match_id: realMatchId,
						matched_user_id: 0,
						ai_profile_id: profile.id,
						profile_name: profile.profile_name || profile.name,
						profile_image: profile.profile_image || profile.image,
						description: profile.description,
						interests: profile.interests || profile.preferences,
						age: profile.age,
						matched_at: Date.now(),
						is_ai_match: true,
						isAI: true
					};

					addToLocalMatches(aiMatch);

					showNotification('🎉 Es ist ein Match! 💕', 'success');
					showMatchAnimation(profile);
					openMatchChat(realMatchId, 0, aiMatch.profile_name, aiMatch.profile_image);
					return;
				}

				// --- normale User-Likes ---
				const response = await fetch('/.netlify/functions/create_match', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						likerId: parseInt(currentUser.uid),
						likedId: parseInt(profile.user_id)
					})
				});

				const result = await response.json();
				if (result.success && result.newMatch) {
					const matchId = result.matchId;
					addToLocalMatches({
						id: matchId,
						match_id: matchId,
						matched_user_id: profile.user_id,
						profile_name: profile.profile_name || profile.name,
						profile_image: profile.profile_image || profile.image,
						matched_at: Date.now(),
						is_ai_match: false
					});
					showNotification('🎉 Es ist ein Match!', 'success');
					openMatchChat(matchId, profile.user_id, profile.profile_name || profile.name, profile.profile_image || profile.image);
				}

			} catch (error) {
				console.error('Fehler beim Like:', error);
				showNotification('❌ Fehler beim Match erstellen', 'error');
			}
		}

		function addToLocalMatches(match) {
			let localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
			const exists = localMatches.some(m => m.match_id == match.match_id);
			if (!exists) {
				localMatches.push(match);
				localStorage.setItem('userMatches', JSON.stringify(localMatches));
				console.log('✅ Match added to localMatches', match.match_id);
			} else {
				console.log('ℹ️ Match already exists (local)', match.match_id);
			}
		}


		function addToLocalMatches(match) {
		  let localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
		  const id = match.match_id || match.id;
		  const exists = localMatches.some(m => m.match_id == id || m.id == id);
		  if (!exists) {
			const store = Object.assign({}, match, { match_id: id, id: id });
			localMatches.push(store);
			localStorage.setItem('userMatches', JSON.stringify(localMatches));
			console.log('✅ Match added to localMatches', id);
		  } else {
			console.log('ℹ️ Match already exists (local)', id);
		  }
		}


		// ✅ UPDATED: Replace your existing showNoMoreCards function
		function showNoMoreCards() {
			// Just call the unified function
			showNoMoreProfilesInCardStack();
		}

		
		async function reloadProfiles() {
			const cardStack = document.getElementById('cardStack');
			const swipeActions = document.querySelector('.swipe-actions');
			
			// Show animated loading
			cardStack.style.cssText = `
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 100px;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				z-index: 1;
			`;
			
			cardStack.innerHTML = `
				<div style="text-align: center; color: white;">
					<div class="infinity-loader">
						<svg width="140" height="80" viewBox="0 0 140 80" xmlns="http://www.w3.org/2000/svg">
							<!-- Main infinity path -->
							<path id="infinityPath" 
								  d="M 20,40 C 20,20 35,10 50,10 C 65,10 70,25 70,40 C 70,55 65,70 50,70 C 35,70 20,60 20,40 Z M 70,40 C 70,25 75,10 90,10 C 105,10 120,20 120,40 C 120,60 105,70 90,70 C 75,70 70,55 70,40 Z" 
								  fill="none" 
								  stroke="url(#infinityGradient)" 
								  stroke-width="4" 
								  stroke-linecap="round"
								  stroke-dasharray="300"
								  stroke-dashoffset="300">
								<animate attributeName="stroke-dashoffset" 
										 values="300;0;300" 
										 dur="6s" 
										 repeatCount="indefinite"/>
							</path>
							
							<!-- Moving particles -->
							<circle r="5" fill="url(#particleGradient)" opacity="0.9">
								<animateMotion dur="5s" repeatCount="indefinite">
									<path d="M 20,40 C 20,20 35,10 50,10 C 65,10 70,25 70,40 C 70,55 65,70 50,70 C 35,70 20,60 20,40 Z M 70,40 C 70,25 75,10 90,10 C 105,10 120,20 120,40 C 120,60 105,70 90,70 C 75,70 70,55 70,40 Z"/>
								</animateMotion>
								<animate attributeName="opacity" values="0.9;0.4;0.9" dur="2s" repeatCount="indefinite"/>
							</circle>
							
							<!-- Second particle (delayed) -->
							<circle r="3" fill="#00ccff" opacity="0.7">
								<animateMotion dur="5s" repeatCount="indefinite" begin="1.5s">
									<path d="M 20,40 C 20,20 35,10 50,10 C 65,10 70,25 70,40 C 70,55 65,70 50,70 C 35,70 20,60 20,40 Z M 70,40 C 70,25 75,10 90,10 C 105,10 120,20 120,40 C 120,60 105,70 90,70 C 75,70 70,55 70,40 Z"/>
								</animateMotion>
								<animate attributeName="opacity" values="0.7;0.2;0.7" dur="3s" repeatCount="indefinite"/>
							</circle>
							
							<!-- Third particle (more delayed) -->
							<circle r="2" fill="#66ff66" opacity="0.6">
								<animateMotion dur="5s" repeatCount="indefinite" begin="3s">
									<path d="M 20,40 C 20,20 35,10 50,10 C 65,10 70,25 70,40 C 70,55 65,70 50,70 C 35,70 20,60 20,40 Z M 70,40 C 70,25 75,10 90,10 C 105,10 120,20 120,40 C 120,60 105,70 90,70 C 75,70 70,55 70,40 Z"/>
								</animateMotion>
							</circle>
							
							<!-- Gradient definitions -->
							<defs>
								<linearGradient id="infinityGradient" x1="0%" y1="0%" x2="100%" y2="0%">
									<stop offset="0%" style="stop-color:#00ff88;stop-opacity:1">
										<animate attributeName="stop-color" 
												 values="#00ff88;#0099ff;#6666ff;#ff0099;#00ff88" 
												 dur="8s" 
												 repeatCount="indefinite"/>
									</stop>
									<stop offset="50%" style="stop-color:#0099ff;stop-opacity:1">
										<animate attributeName="stop-color" 
												 values="#0099ff;#6666ff;#ff0099;#00ff88;#0099ff" 
												 dur="8s" 
												 repeatCount="indefinite"/>
									</stop>
									<stop offset="100%" style="stop-color:#6666ff;stop-opacity:1">
										<animate attributeName="stop-color" 
												 values="#6666ff;#ff0099;#00ff88;#0099ff;#6666ff" 
												 dur="8s" 
												 repeatCount="indefinite"/>
									</stop>
								</linearGradient>
								
								<radialGradient id="particleGradient">
									<stop offset="0%" style="stop-color:#ffffff;stop-opacity:1"/>
									<stop offset="100%" style="stop-color:#00ff88;stop-opacity:0"/>
								</radialGradient>
							</defs>
						</svg>
					</div>
				</div>
				
				<style>
					.infinity-loader {
						animation: float 6s ease-in-out infinite, breathe 4s ease-in-out infinite;
						filter: drop-shadow(0 0 25px rgba(0, 255, 136, 0.6));
					}
					
					@keyframes float {
						0%, 100% { 
							transform: translateY(0px) rotate(0deg); 
						}
						33% { 
							transform: translateY(-8px) rotate(1deg); 
						}
						66% { 
							transform: translateY(5px) rotate(-1deg); 
						}
					}
					
					@keyframes breathe {
						0%, 100% { 
							transform: scale(1);
							opacity: 0.9;
						}
						50% { 
							transform: scale(1.05);
							opacity: 1;
						}
					}
					
					/* Dynamic glow effect */
					.infinity-loader svg {
						animation: dynamicGlow 7s ease-in-out infinite;
					}
					
					@keyframes dynamicGlow {
						0% {
							filter: drop-shadow(0 0 15px rgba(0, 255, 136, 0.5));
						}
						25% {
							filter: drop-shadow(0 0 30px rgba(0, 153, 255, 0.7)) drop-shadow(0 0 45px rgba(0, 255, 136, 0.3));
						}
						50% {
							filter: drop-shadow(0 0 35px rgba(102, 102, 255, 0.8)) drop-shadow(0 0 50px rgba(0, 153, 255, 0.4));
						}
						75% {
							filter: drop-shadow(0 0 25px rgba(255, 0, 153, 0.6)) drop-shadow(0 0 40px rgba(102, 102, 255, 0.5));
						}
						100% {
							filter: drop-shadow(0 0 15px rgba(0, 255, 136, 0.5));
						}
					}
				</style>
			`;
			
			try {
				// Reset state
				currentIndex = 0;
				currentProfiles = [];
				
				// Load profiles with timeout
				const loadPromise = loadProfiles();
				const timeoutPromise = new Promise((_, reject) => 
					setTimeout(() => reject(new Error('timeout')), 5000)
				);
				
				await Promise.race([loadPromise, timeoutPromise]);
				
				// Check if we actually got profiles
				if (!currentProfiles || currentProfiles.length === 0) {
					// Wait a bit then show no profiles message
					setTimeout(() => {
						showNoMoreCards();
					}, 1000);
				}
				
			} catch (error) {
				console.error('Fehler beim Neuladen:', error);
				// Show no profiles after loading attempt
				setTimeout(() => {
					showNoMoreCards();
				}, 1000);
			}
		}		
		// Match Animation
		function showMatchAnimation(profile) {
		    const overlay = document.createElement('div');
		    overlay.style.cssText = `
		        position: fixed;
		        top: 0;
		        left: 0;
		        right: 0;
		        bottom: 0;
		        background: linear-gradient(135deg, #ff6b6b, #ee5a52);
		        display: flex;
		        align-items: center;
		        justify-content: center;
		        z-index: 3000;
		        opacity: 0;
		        transition: opacity 0.3s ease;
		    `;
		    
		    overlay.innerHTML = `
		        <div style="text-align: center; color: white;">
		            <div style="font-size: 6rem; margin-bottom: 20px; animation: pulse 1s infinite;">💕</div>
		            <h2 style="font-size: 2.5rem; margin-bottom: 10px;">It's a Match!</h2>
		            <p style="font-size: 1.2rem; opacity: 0.9;">Du und ${profile.profile_name} habt euch geliked!</p>
		            <button onclick="this.parentElement.parentElement.remove()" 
		                    style="margin-top: 30px; padding: 15px 30px; background: white; color: #333; border: none; border-radius: 25px; font-size: 1.1rem; cursor: pointer;">
		                Weiter swipen
		            </button>
		        </div>
		    `;
		    
		    document.body.appendChild(overlay);
		    
		    // Animation starten
		    setTimeout(() => overlay.style.opacity = '1', 10);
		    
		    // Auto-remove nach 4 Sekunden
		    setTimeout(() => {
		        if (overlay.parentElement) {
		            overlay.remove();
		        }
		    }, 4000);
		}		
		
		// Function to check user status and update UI
		async function checkUserPlusStatus() {
			if (!currentUser || !currentUser.uid) return;
			
			try {
				const response = await fetch('/.netlify/functions/get_user_status', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});
				
				const result = await response.json();
				if (result.success) {
					isUserPlus = result.isUserPlus;
					isAdmin = result.isAdmin;
					updatePremiumButtons();
				}
			} catch (error) {
				console.error('Fehler beim Überprüfen des UserPlus-Status:', error);
			}
		}

		function updateFloatingButtons() {
			const profileBtn = document.getElementById('profileButton');
			const chatBtn = document.getElementById('chatButton');
			
			if (!profileBtn || !chatBtn) return;
			
			if (currentUser && currentUser.uid) {
				const swipeContainer = document.getElementById('swipeContainer');
				const isSwipeView = swipeContainer && window.getComputedStyle(swipeContainer).display === 'block';
				
				if (isSwipeView) {
					// Force show with important styles
					profileBtn.classList.remove('hidden');
					chatBtn.classList.remove('hidden');
					
					profileBtn.style.cssText = `
						position: fixed !important;
						bottom: 2rem !important;
						left: 2rem !important;
						width: 4rem !important;
						height: 4rem !important;
						border-radius: 50% !important;
						background-color: #ff5e5e !important;
						color: white !important;
						display: flex !important;
						align-items: center !important;
						justify-content: center !important;
						box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
						cursor: pointer !important;
						z-index: 5 !important;
						border: none !important;
						visibility: visible !important;
						opacity: 1 !important;
					`;
					
					chatBtn.style.cssText = `
						position: fixed !important;
						bottom: 2rem !important;
						right: 2rem !important;
						width: 4rem !important;
						height: 4rem !important;
						border-radius: 50% !important;
						background-color: #007bff !important;
						color: white !important;
						display: flex !important;
						align-items: center !important;
						justify-content: center !important;
						box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
						cursor: pointer !important;
						z-index: 2000 !important;
						border: none !important;
						visibility: visible !important;
						opacity: 1 !important;
					`;
				} else {
					profileBtn.classList.add('hidden');
					chatBtn.classList.add('hidden');
				}
			} else {
				profileBtn.classList.add('hidden');
				chatBtn.classList.add('hidden');
			}
		}
				
		function updateSwipeActionButtons() {
			const existingButtons = document.querySelector('.floating-buttons');
			if (existingButtons) {
				existingButtons.remove();
			}

			const swipeContainer = document.getElementById('swipeContainer');
			const currentScreen = swipeContainer && swipeContainer.style.display === 'block';
			
			if (!currentScreen) return;

			const buttonsHtml = `
				<div class="floating-buttons fixed bottom-1 left-1/2 transform -translate-x-1/2 flex items-center space-x-4 z-50">
					<!-- Swipe Back Button (UserPlus only) -->
					<button id="swipeBackBtn" 
							onclick="swipeBack()" 
							class="premium-btn ${!isUserPlus && !isAdmin ? 'premium-btn-locked' : 'premium-btn-active'} 
								   w-12 h-12 rounded-full flex items-center justify-center transition-all duration-300 shadow-lg"
							${!isUserPlus && !isAdmin ? 'disabled' : ''}>
						<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
							<path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
						</svg>
						${!isUserPlus && !isAdmin ? '<span class="premium-lock">🔒</span>' : ''}
					</button>
					
					<!-- Dislike Button -->
					<button onclick="swipeCard('left')" 
							class="bg-white text-red-500 border-2 border-red-200 w-16 h-16 rounded-full flex items-center justify-center hover:bg-red-50 transition-all duration-300 shadow-lg">
						<svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24">
							<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
						</svg>
					</button>
					
					<!-- Like Button -->
					<button onclick="swipeCard('right')" 
							class="bg-gradient-to-r from-pink-500 to-red-500 text-white w-16 h-16 rounded-full flex items-center justify-center hover:from-pink-600 hover:to-red-600 transition-all duration-300 shadow-lg">
						<svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24">
							<path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
						</svg>
					</button>
					
					<!-- InstaMatch Button (UserPlus only) -->
					<button id="instaMatchBtn" 
							onclick="instaMatch()" 
							class="premium-btn ${!isUserPlus && !isAdmin ? 'premium-btn-locked' : 'premium-btn-active'} 
								   w-12 h-12 rounded-full flex items-center justify-center transition-all duration-300 shadow-lg"
							${!isUserPlus && !isAdmin ? 'disabled' : ''}>
						<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
							<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
						</svg>
						${!isUserPlus && !isAdmin ? '<span class="premium-lock">🔒</span>' : ''}
					</button>
				</div>
			`;

			document.body.insertAdjacentHTML('beforeend', buttonsHtml);
		}	

		// Swipe Back functionality
		async function swipeBack() {
			if (!isUserPlus && !isAdmin) {
				showUserPlusPurchase();
				return;
			}
			
			if (!currentUser || !currentUser.uid) {
				showNotification('❌ Bitte melden Sie sich an', 'error');
				return;
			}
			
			try {
				const response = await fetch('/.netlify/functions/swipe_back', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});
				
				const result = await response.json();
				
				if (result.success && result.profile) {
					// Add the profile back to the beginning
					currentProfiles.unshift(result.profile);
					currentIndex = Math.max(0, currentIndex - 1);
					
					// Re-render cards
					renderSwipeCards();
					
					showNotification('✅ Letzter Swipe rückgängig gemacht!', 'success');
				} else {
					showNotification(result.message || '❌ Kein vorheriger Swipe gefunden', 'info');
				}
			} catch (error) {
				console.error('Fehler beim Swipe Back:', error);
				showNotification('❌ Fehler beim Swipe Back', 'error');
			}
		}

		// InstaMatch functionality
		async function instaMatch() {
			if (!isUserPlus && !isAdmin) {
				showUserPlusPurchase();
				return;
			}
			
			const activeCard = document.querySelector('.swipe-card[data-stack-index="0"]');
			if (!activeCard || !activeCard.__profile) {
				showNotification('❌ Kein Profil zum Matchen verfügbar', 'error');
				return;
			}
			
			const profile = activeCard.__profile;
			
			if (profile.isAI) {
				// Handle AI InstaMatch
				await handleLike(profile);
				completeSwipe('right');
			} else {
				// Handle real user InstaMatch
				try {
					const response = await fetch('/.netlify/functions/create_match', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							likerId: parseInt(currentUser.uid),
							likedId: parseInt(profile.user_id),
							isInstaMatch: true
						})
					});
					
					const result = await response.json();
					
					if (result.success) {
						showNotification('⚡ InstaMatch erfolgreich!', 'success');
						showMatchAnimation(profile);
						completeSwipe('right');
					} else {
						showNotification('❌ InstaMatch fehlgeschlagen', 'error');
					}
				} catch (error) {
					console.error('Fehler beim InstaMatch:', error);
					showNotification('❌ Fehler beim InstaMatch', 'error');
				}
			}
		}
		
		// Add UserPlus option to sidebar
		function addUserPlusToSidebar() {
			const sidebar = document.getElementById('sidebar');
			if (!sidebar) return;
			
			const userPlusItem = document.createElement('a');
			userPlusItem.href = '#';
			userPlusItem.onclick = () => {
				if (isUserPlus || isAdmin) {
					showNotification('Du hast bereits UserPlus! 🎉', 'success');
				} else {
					showUserPlusPurchase();
				}
				closeSidebar();
			};
			
			userPlusItem.innerHTML = `
				<div class="flex items-center space-x-3 p-3 hover:bg-gray-100 rounded-lg transition-colors">
					<div class="w-8 h-8 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full flex items-center justify-center">
						<span class="text-white text-lg">⭐</span>
					</div>
					<div class="flex-1">
						<div class="font-semibold text-gray-800">${isUserPlus || isAdmin ? 'UserPlus Aktiv' : 'UserPlus kaufen'}</div>
						<div class="text-xs text-gray-500">${isUserPlus || isAdmin ? 'Premium Features aktiv' : '€4,99 - Swipe Back & InstaMatch'}</div>
					</div>
					${isUserPlus || isAdmin ? '<span class="text-green-500">✓</span>' : '<span class="text-purple-500">€4,99</span>'}
				</div>
			`;
			
			// Insert after profile option (assuming it exists)
			const profileLink = sidebar.querySelector('a[onclick*="showProfilePopup"]');
			if (profileLink && profileLink.parentNode) {
				profileLink.parentNode.insertBefore(userPlusItem, profileLink.nextSibling);
			} else {
				sidebar.appendChild(userPlusItem);
			}
		}

		// Initialize UserPlus features when user logs in
		async function initializeUserPlusFeatures() {
			await checkUserPlusStatus();
			addUserPlusToSidebar();
			updateFloatingButtons();
			updateSwipeActionButtons();
		}		

		// Show UserPlus purchase modal
		function showUserPlusPurchase() {
			const modalHtml = `
				<div class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4" onclick="closeUserPlusPurchase()">
					<div class="bg-white rounded-2xl max-w-md w-full p-6" onclick="event.stopPropagation()">
						<div class="text-center">
							<div class="text-6xl mb-4">⭐</div>
							<h2 class="text-2xl font-bold mb-4 text-gray-800">
								UserPlus für €4,99
								<span style="color: #6b7280; font-size: 0.6em; vertical-align: super;">*</span>
							</h2>
							<div class="text-left mb-6 space-y-3">
								<div class="flex items-center">
									<div class="w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center mr-3">
										<svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 24 24">
											<path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
										</svg>
									</div>
									<span class="text-gray-700">Swipe Back - Letzten Swipe rückgängig machen</span>
								</div>
								<div class="flex items-center">
									<div class="w-6 h-6 bg-yellow-500 rounded-full flex items-center justify-center mr-3">
										<svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 24 24">
											<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
										</svg>
									</div>
									<span class="text-gray-700">InstaMatch - Sofortiges Match ohne gegenseitigen Like</span>
									<span style="color: #6b7280; font-size: 0.6em; vertical-align: super;">**</span>
								</div>
							</div>
							
							<div id="paypal-button-container" class="my-4"></div>
							
							<button onclick="closeUserPlusPurchase()" 
									class="w-full bg-gray-200 text-gray-700 py-2 px-6 rounded-full hover:bg-gray-300 transition-colors">
								Später
							</button>
							<p style="text-align: center; color: #6b7280; font-size: 0.8em; margin-top: 5px;">
								*UserPlus für 4,99€ ist nach dem Kauf eine Woche gültig und
							<p style="text-align: center; color: #6b7280; font-size: 0.8em; margin-top: -5px; margin-right: 165px">
								wird nicht automatisch erneuert
							<p style="text-align: center; color: #6b7280; font-size: 0.8em; margin-top: 1px; margin-right: 205px">
								**Verfügbar einmal Pro Tag
							</p>
						</div>
					</div>
				</div>
			`;
			
			const existingModal = document.querySelector('[data-userplus-modal]');
			if (existingModal) {
				existingModal.remove();
			}
			
			const modalDiv = document.createElement('div');
			modalDiv.setAttribute('data-userplus-modal', 'true');
			modalDiv.innerHTML = modalHtml;
			document.body.appendChild(modalDiv);
			
			purchaseUserPlus();

		}

		function closeUserPlusPurchase() {
			const modal = document.querySelector('[data-userplus-modal]');
			if (modal) {
				modal.remove();
			}
		}

		// Purchase UserPlus via PayPal Sandbox
		async function purchaseUserPlus() {
			if (!currentUser || !currentUser.uid) {
				showNotification('❌ Bitte melden Sie sich an', 'error');
				return;
			}

			// Render PayPal-Button in den Container
			paypal.Buttons({
				style: {
					shape: 'pill',
					color: 'blue',
					layout: 'vertical',
					label: 'paypal'
				},
				createOrder: function(data, actions) {
					return actions.order.create({
						purchase_units: [{
							amount: {
								value: '4.99',
								currency_code: 'EUR'
							}
						}]
					});
				},
				onApprove: function(data, actions) {
					return actions.order.capture().then(async function(details) {
						try {
							const orderId = data.orderID;

							// Order-ID an dein Netlify Backend schicken
							const response = await fetch('/.netlify/functions/purchase_userplus', {
								method: 'POST',
								headers: { 'Content-Type': 'application/json' },
								body: JSON.stringify({
									userId: currentUser.uid,
									paymentToken: orderId
								})
							});

							const result = await response.json();

							if (result.success) {
								isUserPlus = true;
								updatePremiumButtons();
								closeUserPlusPurchase();
								showNotification('🎉 UserPlus erfolgreich aktiviert!', 'success');
							} else {
								showNotification('❌ Kauf fehlgeschlagen: ' + result.error, 'error');
							}
						} catch (error) {
							console.error('Fehler beim UserPlus Kauf:', error);
							showNotification('❌ Fehler beim Kauf', 'error');
						}
					});
				},
				onError: function(err) {
					console.error('PayPal-Fehler:', err);
					showNotification('❌ PayPal-Fehler beim Kauf', 'error');
				}
			}).render('#paypal-button-container');
		}


		// Update premium buttons styling
		function updatePremiumButtons() {
			const swipeBackBtn = document.getElementById('swipeBackBtn');
			const instaMatchBtn = document.getElementById('instaMatchBtn');
			
			if (swipeBackBtn) {
				if (isUserPlus || isAdmin) {
					swipeBackBtn.classList.remove('premium-btn-locked');
					swipeBackBtn.classList.add('premium-btn-active');
					swipeBackBtn.disabled = false;
					const lock = swipeBackBtn.querySelector('.premium-lock');
					if (lock) lock.remove();
				} else {
					swipeBackBtn.classList.add('premium-btn-locked');
					swipeBackBtn.classList.remove('premium-btn-active');
					swipeBackBtn.disabled = true;
					if (!swipeBackBtn.querySelector('.premium-lock')) {
						swipeBackBtn.innerHTML += '<span class="premium-lock">🔒</span>';
					}
				}
			}
			
			if (instaMatchBtn) {
				if (isUserPlus || isAdmin) {
					instaMatchBtn.classList.remove('premium-btn-locked');
					instaMatchBtn.classList.add('premium-btn-active');
					instaMatchBtn.disabled = false;
					const lock = instaMatchBtn.querySelector('.premium-lock');
					if (lock) lock.remove();
				} else {
					instaMatchBtn.classList.add('premium-btn-locked');
					instaMatchBtn.classList.remove('premium-btn-active');
					instaMatchBtn.disabled = true;
					if (!instaMatchBtn.querySelector('.premium-lock')) {
						instaMatchBtn.innerHTML += '<span class="premium-lock">🔒</span>';
					}
				}
			}
		}
				

		function updateChatButtonBadge() {
			const chatBtn = document.getElementById('chatButton');
			if (!chatBtn) return;
			
			// Remove existing badge
			const existingBadge = chatBtn.querySelector('.notification-badge');
			if (existingBadge) {
				existingBadge.remove();
			}
			
			if (unreadMessageCount > 0) {
				const badge = document.createElement('div');
				badge.className = 'notification-badge';
				badge.textContent = unreadMessageCount > 99 ? '99+' : unreadMessageCount.toString();
				badge.style.cssText = `
					position: absolute !important;
					top: -8px !important;
					right: -8px !important;
					background-color: #ff4444 !important;
					color: white !important;
					border-radius: 50% !important;
					width: 24px !important;
					height: 24px !important;
					display: flex !important;
					align-items: center !important;
					justify-content: center !important;
					font-size: 12px !important;
					font-weight: bold !important;
					border: 2px solid white !important;
					animation: pulse 2s infinite !important;
					z-index: 2001 !important;
				`;
				chatBtn.appendChild(badge);
				
				// Add pulsing animation CSS if not already present
				if (!document.getElementById('notification-styles')) {
					const style = document.createElement('style');
					style.id = 'notification-styles';
					style.textContent = `
						@keyframes pulse {
							0% { transform: scale(1); }
							50% { transform: scale(1.1); }
							100% { transform: scale(1); }
						}
					`;
					document.head.appendChild(style);
				}
			}
		}

		// Function to check for new messages across all chats
		async function checkForNewMessages() {
			if (!currentUser || !currentUser.uid) return;
			
			let newMessageCount = 0;
			
			try {
				// Check real user matches
				const matchesResponse = await fetch('/.netlify/functions/get_matches', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});
				
				if (matchesResponse.ok) {
					const matchesResult = await matchesResponse.json();
					if (matchesResult.success && matchesResult.matches) {
						
						for (const match of matchesResult.matches) {
							const matchId = match.match_id;
							
							// Get messages for this match
							const messagesResponse = await fetch('/.netlify/functions/get_messages', {
								method: 'POST',
								headers: { 'Content-Type': 'application/json' },
								body: JSON.stringify({ match_id: matchId })
							});
							
							if (messagesResponse.ok) {
								const messagesResult = await messagesResponse.json();
								if (messagesResult.success && messagesResult.messages) {
									const messages = messagesResult.messages;
									const lastChecked = lastCheckedMessages[matchId] || 0;
									
									// Count unread messages from partner
									const unreadFromPartner = messages.filter(msg => 
										msg.sender_id !== parseInt(currentUser.uid) && 
										new Date(msg.sent_at).getTime() > lastChecked
									).length;
									
									newMessageCount += unreadFromPartner;
								}
							}
						}
					}
				}
				
				// Check AI matches
				const localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
				const aiMatches = localMatches.filter(m => m.isAI);
				
				for (const aiMatch of aiMatches) {
					const chatId = aiMatch.match_id;
					const aiMessages = JSON.parse(localStorage.getItem(`ai_chat_${chatId}`) || '[]');
					const lastChecked = lastCheckedMessages[chatId] || 0;
					
					// Count unread messages from AI
					const unreadFromAI = aiMessages.filter(msg => 
						msg.sender === 'ai' && 
						new Date(msg.timestamp).getTime() > lastChecked
					).length;
					
					newMessageCount += unreadFromAI;
				}
				
				unreadMessageCount = newMessageCount;
				updateChatButtonBadge();
				
			} catch (error) {
				console.error('Error checking for new messages:', error);
			}
		}

		// Function to mark messages as read for a specific chat
		function markMessagesAsRead(matchId) {
			lastCheckedMessages[matchId] = Date.now();
			localStorage.setItem('lastCheckedMessages', JSON.stringify(lastCheckedMessages));
			
			// Recheck total unread count
			setTimeout(checkForNewMessages, 100);
		}
				
		function initializeNotificationSystem() {
			// Load last checked messages from localStorage
			const stored = localStorage.getItem('lastCheckedMessages');
			if (stored) {
				lastCheckedMessages = JSON.parse(stored);
			}
			
			// Check for messages immediately
			if (currentUser && currentUser.uid) {
				checkForNewMessages();
				
				// Set up periodic checking (every 30 seconds)
				setInterval(checkForNewMessages, 30000);
			}
		}		


        function addMatch(profile) {
            if (!matches.find(m => m.id === profile.id)) {
                matches.push({
                    ...profile,
                    matchedAt: new Date().toISOString(),
                    messages: [
                        {
                            text: `Hey! Schön, dass wir gematcht haben! 😊`,
                            sender: 'system',
                            timestamp: new Date().toISOString()
                        }
                    ]
                });
                localStorage.setItem('matches', JSON.stringify(matches));
            }
        }

        // Chat Functions
        function showMatchesList() {
            document.getElementById('matchesList').style.display = 'block';
            document.getElementById('individualChat').style.display = 'none';
            loadUserMatches(true);
			startMatchesAutoRefresh();
        }

		
		   async function uploadImageToCloudinary(file) {
            console.log('📄 Starting Cloudinary upload for file:', file.name, file.type, file.size);
            
            if (!file.type.startsWith('image/')) {
                throw new Error('Datei ist kein Bild');
            }
            
            if (file.size > 16 * 1024 * 1024) {
                throw new Error('Datei ist zu groß (max 16MB)');
            }
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('upload_preset', 'benches_upload');
            
            try {
                console.log('📤 Uploading to Cloudinary...');
                const response = await fetch('https://api.cloudinary.com/v1_1/dp3t4ctxz/image/upload', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Cloudinary error response:', errorText);
                    
                    let errorMessage = 'Cloudinary-Upload fehlgeschlagen';
                    try {
                        const errorData = JSON.parse(errorText);
                        if (errorData.error && errorData.error.message) {
                            errorMessage += ': ' + errorData.error.message;
                        }
                    } catch (e) {
                        // Fallback wenn Error nicht parsbar ist
                    }
                    
                    throw new Error(errorMessage);
                }
                
                const data = await response.json();
                console.log('✅ Cloudinary upload successful:', data);
                
                await testImageUrl(data.secure_url);
                
                return data.secure_url;
                
            } catch (error) {
                console.error('❌ Upload error:', error);
                throw error;
            }
        }

        function testImageUrl(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    console.log('✅ Uploaded image URL is accessible:', url);
                    resolve();
                };
                img.onerror = () => {
                    console.error('❌ Uploaded image URL is NOT accessible:', url);
                    reject(new Error('Uploaded image is not accessible'));
                };
                img.src = url;
                
                setTimeout(() => {
                    reject(new Error('Image test timeout'));
                }, 10000);
            });
        }
				
		function escapeHtml(text) {
			const map = {
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;',
				'"': '&quot;',
				"'": '&#039;'
			};
			return text.replace(/[&<>"']/g, function(m) { return map[m]; });
		}
		

        function suggestBench() {
            if (!currentChatUser) return;
            
            // Add system message
            if (!currentChatUser.messages) {
                currentChatUser.messages = [];
            }
            
            currentChatUser.messages.push({
                text: "💡 Lass uns eine schöne Bank zum Treffen finden!",
                sender: 'me',
                timestamp: new Date().toISOString()
            });
            
            localStorage.setItem('matches', JSON.stringify(matches));
            
            // Redirect to map with special parameter
            const mapUrl = `index.html?match=${currentChatUser.id}&suggest=true`;
            window.open(mapUrl, '_blank');
            
            showNotification('🗺️ Du wirst zur Bank-Karte weitergeleitet...', 'success');
        }

        // Utility Functions
        function showNotification(message, type) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 5000);
        }

        function showAbout() {
            showNotification('ℹ️ One-T-Meet: Finde die Liebe auf den schönsten Bänken der Welt! 💕🪑', 'success');
            closeSidebar();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', e => { 
            if (e.key === 'Escape') { 
                closeLogin();
                if (sidebarOpen) closeSidebar();
            }
            
            // Swipe shortcuts
            if (document.getElementById('swipeContainer').style.display === 'block') {
                if (e.key === 'ArrowLeft') swipeCard('left');
                if (e.key === 'ArrowRight') swipeCard('right');
            }
        });

        // Enter key for message input
        document.addEventListener('keydown', e => {
            if (e.key === 'Enter' && document.activeElement.id === 'messageInput') {
                sendMessage();
            }
        });
        document.getElementById('profileImage').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const button = document.querySelector('.file-upload-btn');
            const status = document.getElementById('fileStatus');
            const buttonText = document.getElementById('fileButtonText');
            
            if (file) {
                button.classList.add('has-file');
                buttonText.textContent = 'Bild ausgewählt';
                status.textContent = `Ausgewählt: ${file.name}`;
                status.style.color = '#4caf50';
            } else {
                button.classList.remove('has-file');
                buttonText.textContent = 'Bild auswählen';
                status.textContent = 'Kein Bild ausgewählt';
                status.style.color = '#b0b0b0';
            }
        });	
		// Gender-Auswahl Event Listener
		document.querySelectorAll('.gender-btn').forEach(btn => {
			btn.addEventListener('click', function() {
				document.querySelectorAll('.gender-btn').forEach(b => b.classList.remove('selected'));
				this.classList.add('selected');
				selectedGender = this.dataset.gender;
				document.getElementById('genderError').style.display = 'none';
			});
		});

		// Name-Validierung (nur Buchstaben, max 16 Zeichen)
		document.getElementById('profileName').addEventListener('input', function() {
			const value = this.value;
			const cleanValue = value.replace(/[^a-zA-ZäöüÄÖÜß\s]/g, '');
			if (cleanValue !== value) {
				this.value = cleanValue;
			}
			document.getElementById('nameCount').textContent = `${cleanValue.length}/16`;
		});

		// Alter-Validierung (18-99)
		document.getElementById('profileAge').addEventListener('input', function() {
			const age = parseInt(this.value);
			const ageError = document.getElementById('ageError');
			if (age < 18) {
				ageError.textContent = 'Mindestalter ist 18 Jahre';
				ageError.style.display = 'block';
			} else {
				ageError.style.display = 'none';
			}
		});

		// Beschreibung-Validierung (max 2 Sätze, 200 Zeichen)
		document.getElementById('profileDescription').addEventListener('input', function() {
			const value = this.value;
			const sentences = value.split(/[.!?]+/).filter(s => s.trim().length > 0);
			document.getElementById('descriptionCount').textContent = `${value.length}/200`;
			
			const descError = document.getElementById('descriptionError');
			if (sentences.length > 2) {
				descError.textContent = 'Maximal 2 Sätze erlaubt';
				descError.style.display = 'block';
			} else {
				descError.style.display = 'none';
			}
		});

		document.addEventListener('DOMContentLoaded', function() {
		    console.log('🚀 App wird initialisiert...');
		    
		    // Globale Variablen (falls sie hier initialisiert werden)
		    currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
		    matches = JSON.parse(localStorage.getItem('matches') || '[]');
		    currentProfile = JSON.parse(localStorage.getItem('currentProfile') || 'null');
		    
		    // UI-Aktualisierungen
		    updateAuthButtons();
		    generateSampleProfiles();
		    renderPreferences();
		    checkAndRenderUI(); // Diese Funktion sollte alle weiteren Schritte auslösen
			renderHobbies();

			const profileForm = document.getElementById('profileForm');
			if (profileForm) {
				profileForm.addEventListener('submit', createProfile);
			}
					
		    // Event-Listener für Buttons
		    const profileBtn = document.getElementById('profileButton');
		    const chatBtn = document.getElementById('chatButton');
		    
		    if (profileBtn) {
		        profileBtn.addEventListener('click', showProfilePopup);
		    }
		    
		    if (chatBtn) {
		        chatBtn.addEventListener('click', showMatches);
		    }
		    
		    console.log('✅ App initialisiert');
		    
		    // Debug Info
		    if (currentUser) {
		        console.log('👤 User angemeldet:', currentUser.email);
		    } else {
		        console.log('👤 Kein User angemeldet');
		    }
		    // Force initial floating button setup
		    if (currentUser) {
		        setTimeout(() => {
		            updateFloatingButtons();
		        }, 500);
		    }
		});		
    </script>
</body>
</html>
