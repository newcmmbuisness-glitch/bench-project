<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>One To Meet</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
	<script src="https://www.paypal.com/sdk/js?client-id=Adk-v-jGvp2KRbnoJkSvcKNsPqhdlj4tC_pEWtpBMhZrgbOw7h_MeV94UbYvwspxFidq2mpcAYxbedT5&currency=EUR"></script>
	<link rel="stylesheet" href="style.css">

</head>
<body>
    <div id="modalOverlay" class="fixed inset-0 bg-black opacity-50 z-10 hidden"></div>
	
	<div class="main-logo" id="mainLogo">
		<img src="OB.png" alt="OB Logo">
	</div>

	<div id="sidebar" class="sidebar">
		<div class="sidebar-header">
			<div class="sidebar-logo">
				<img src="OB.png" alt="OB Logo" style="width: 100%; height: 100%; border-radius: 50%; object-fit: contain;">
			</div>
			<div class="sidebar-title">One-T-Meet</div>
		</div>
		<div class="sidebar-content">
			<a href="#" class="sidebar-item" id="loginSidebarBtn">
				<span class="sidebar-icon">🔐</span>
				<span>Anmelden</span>
			</a>
			<a href="#" class="sidebar-item" id="logoutSidebarBtn" style="display: none;">
				<span class="sidebar-icon">🚪</span>
				<span>Abmelden</span>
			</a>
			<a href="index.html" class="sidebar-item">
				<span class="sidebar-icon">🗺️</span>
				<span>Zur Bench-Karte</span>
			</a>
			<a href="contact.html" class="sidebar-item">
				<span class="sidebar-icon">📧</span>
				<span>Kontakt</span>
			</a>
		</div>
		<div class="sidebar-footer" id="user-email-display"></div>
	</div>

	<div class="sidebar-overlay" id="sidebarOverlay"></div>

	
	<div id="loginModal" class="modal">
	  <div class="modal-content">
		<span class="close" id="loginCloseBtn">&times;</span>
		<h2>Anmelden / Registrieren</h2>
		<div class="auth-tabs">
		  <button class="tab-btn active" id="loginTabBtn">Anmelden</button>
		  <button class="tab-btn" id="registerTabBtn">Registrieren</button>
		</div>
		<div id="loginTab" class="tab-content active">
		  <form id="loginForm">
			<input type="email" id="loginEmail" placeholder="E-Mail" required>
			<input type="password" id="loginPassword" placeholder="Passwort" required>
			<div class="captcha-box">
			  <p id="loginCaptcha"></p>
			  <input type="number" id="loginCaptchaAnswer" placeholder="Antwort" required>
			</div>
			<button type="submit">Anmelden</button>
			<p style="margin-top:10px;">
			  <a href="#" id="passwordResetLink">Passwort vergessen?</a>
			</p>
		  </form>
		</div>

		<div id="registerTab" class="tab-content">
		  <form id="registerForm">
			<input type="email" id="registerEmail" placeholder="E-Mail" required>
			<input type="password" id="registerPassword" placeholder="Passwort" required>
			<input type="password" id="registerPasswordConfirm" placeholder="Passwort bestätigen" required>
			<div class="captcha-box">
			  <p id="registerCaptcha"></p>
			  <input type="number" id="registerCaptchaAnswer" placeholder="Antwort" required>
			</div>
			<button type="submit">Registrieren</button>
		  </form>
		</div>

		<div id="passwordResetDiv" style="display:none;">
		  <form id="passwordResetForm">
			<input type="email" id="resetEmail" placeholder="E-Mail zum Zurücksetzen" required>
			<button type="submit">Passwort zurücksetzen</button>
			<button type="button" id="passwordResetCancelBtn">Abbrechen</button>
		  </form>
		</div>
	  </div>
	</div>
    
	<div class="app-container">
		<div id="welcomeScreen" style="padding:4rem 2rem; max-width:900px; margin:0 auto; text-align:center;">


			<h1 class="shimmer" style="font-size:2.8rem; margin-bottom:1rem;">OneConnect</h1>
			<h2 class="shimmer" style="font-size:1.5rem; margin-bottom:3rem;">One-To-Meet x OneBenches</h2>

			<div style="margin-bottom:3rem; font-size:1rem; line-height:1.6;">
				<p>Registrieren</p>
				<p>Profil erstellen</p>
				<div style="margin-bottom:3rem;">
					<button class="white-btn" onclick="showLogin()">Loslegen</button>
				</div>
			</div>

			<h3 style="font-size:1.3rem; margin-bottom:1rem;">One-To-Meet ist die Zukunft</h3>
			<p style="margin-bottom:3rem;">Online Dating ohne Limit</p>

			<!-- Vergleichstabelle -->
			<table style="width:100%; border-collapse:collapse; margin-bottom:4rem; text-align:center; font-size:0.9rem;">
				<tr>
					<th style="border:1px solid #888; padding:8px;">&nbsp;</th>
					<th style="border:1px solid #888; padding:8px;">One-To-Meet</th>
					<th style="border:1px solid #888; padding:8px;">Standard Date-Apps</th>
				</tr>
				<tr>
					<td style="border:1px solid #888; padding:8px;">Kostenlos Unendlich Swipen</td>
					<td style="border:1px solid #888; padding:8px;">✅</td>
					<td style="border:1px solid #888; padding:8px;">❌</td>
				</tr>
				<tr>
					<td style="border:1px solid #888; padding:8px;">Ohne Begrenzung Daten</td>
					<td style="border:1px solid #888; padding:8px;">✅</td>
					<td style="border:1px solid #888; padding:8px;">❌</td>
				</tr>
				<tr>
					<td style="border:1px solid #888; padding:8px;">Date-Chat KI Unterstützung</td>
					<td style="border:1px solid #888; padding:8px;">✅</td>
					<td style="border:1px solid #888; padding:8px;">❌</td>
				</tr>
			</table>

			<h2 style="margin:3rem 0;" class="shimmer">x OneBenches x</h2>

			<p style="max-width:700px; margin:0 auto 2rem auto; line-height:1.6; font-size:0.95rem;">
				Erstelle und Suche Bänke in deiner Gegend – beim Wandern, mit deinen Freunden oder deinem Date.<br>
				Beim Sonnenuntergang Wein trinken oder eine Tüte zünden.
			</p>

			<h2 style="margin-bottom:2rem;" class="shimmer">x OneBenches x</h2>
			<p style="margin-bottom:3rem;">Komm raus mit OneBenches</p>

			<blockquote style="font-style:italic; opacity:0.8; font-size:0.9rem;">“Peace can’t be found without searching”</blockquote>
		</div>

	    
	    <div id="createProfileSection" class="relative z-0 p-4 w-full h-screen flex flex-col items-center justify-center" style="display: none;">
	        <button onclick="showCreateProfileForm()" class="bg-white text-blue-600 font-bold py-4 px-8 rounded-full shadow-lg hover:bg-gray-200 transition duration-300 transform scale-105 hover:scale-110">
	            <span class="text-xl">Profil erstellen</span>
	        </button>
	    </div>	    
	
		<div id="createProfileModal" class="modal" style="display: none;">
			<div class="modal-content profile-creation">
				<span class="close" onclick="closeCreateProfile()">&times;</span>
				<h2 class="shimmer">Erstelle dein Profil</h2>
				<form id="profileForm">
			
					<!-- Gender Selection -->
					<div class="form-group">
						<label>Geschlecht:</label>
						<div class="gender-selection">
							<div class="gender-btn" data-gender="male">👨 Männlich</div>
							<div class="gender-btn" data-gender="female">👩 Weiblich</div>
						</div>
						<div id="genderError" class="error" style="display: none;"></div>
					</div>

					<!-- Profile Image -->
					<div class="form-group">
						<label>Profilbild:</label>
						<div class="modern-file-upload">
							<button type="button" class="file-upload-btn" onclick="document.getElementById('profileImage').click()">
								<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
									<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
								</svg>
								<span id="fileButtonText">Bild auswählen</span>
							</button>
							<input type="file" id="profileImage" accept="image/*" required style="display: none;">
							<div id="fileStatus">Kein Bild ausgewählt</div>
						</div>
					</div>

					<!-- Name and Age Row -->
					<div class="form-row">
						<div class="form-group">
							<label>👤 Name:</label>
							<input type="text" id="profileName" placeholder="Dein Name" maxlength="16" required>
							<div id="nameError" class="error" style="display: none;"></div>
							<div id="nameCount" class="character-count">0/16</div>
						</div>
						<div class="form-group">
							<label>🎂 Alter:</label>
							<input type="number" id="profileAge" placeholder="Dein Alter" min="18" max="99" required>
							<div id="ageError" class="error" style="display: none;"></div>
						</div>
					</div>

					<!-- Postal Code - Smaller -->
					<div class="form-group">
						<label for="postalCode">Postleitzahl:</label>
						<input type="text" id="postalCode" placeholder="z.B. 10115" maxlength="10">
					</div>

					<!-- Description -->
					<div class="form-group">
						<label>📝 Kurze Beschreibung (max. 2 Sätze):</label>
						<textarea id="profileDescription" rows="3" placeholder="Erzähl etwas über dich..." maxlength="200" required></textarea>
						<div id="descriptionError" class="error" style="display: none;"></div>
						<div id="descriptionCount" class="character-count">0/200</div>
					</div>


					<!-- Genussmittel -->
					<div class="form-group">
						<label>Genussmittel:</label>
						<div id="preferencesIcons" class="preferences-icons"></div>
					</div>

					<!-- Hobbies -->
					<div class="form-group">
						<label>Wähle deine Interessen:</label>
						<div id="hobbiesIcons" class="preferences-icons"></div>
					</div>

					<!-- Questions -->
					<div class="form-group">
						<label>Wähle 2 Fragen über dich:</label>
						<select id="prompt1Select" required>
							<option value="">Wähle eine Frage aus...</option>
							<option value="Ein perfekter erster Date ist...">Ein perfekter erster Date ist...</option>
							<option value="Ich bin gerade besessen von...">Ich bin gerade besessen von...</option>
							<option value="Zwei Wahrheiten und eine Lüge...">Zwei Wahrheiten und eine Lüge...</option>
							<option value="Mein liebstes Reiseziel ist...">Mein liebstes Reiseziel ist...</option>
							<option value="Was ich in meiner Freizeit tue...">Was ich in meiner Freizeit tue...</option>
						</select>
						<input type="text" id="answer1Input" placeholder="Deine Antwort..." style="margin-top: 10px;">
					</div>

					<div class="form-group">
						<select id="prompt2Select" required>
							<option value="">Wähle eine zweite Frage aus...</option>
							<option value="Ein perfekter erster Date ist...">Ein perfekter erster Date ist...</option>
							<option value="Ich bin gerade besessen von...">Ich bin gerade besessen von...</option>
							<option value="Zwei Wahrheiten und eine Lüge...">Zwei Wahrheiten und eine Lüge...</option>
							<option value="Mein liebstes Reiseziel ist...">Mein liebstes Reiseziel ist...</option>
							<option value="Was ich in meiner Freizeit tue...">Was ich in meiner Freizeit tue...</option>
						</select>
						<input type="text" id="answer2Input" placeholder="Deine Antwort..." style="margin-top: 10px;">
					</div>

					<div class="action-buttons">
						<button type="submit" class="action-btn btn-primary">
							Profil speichern
						</button>
						<button type="button" class="action-btn btn-secondary" onclick="closeCreateProfile()">
							Zurück
						</button>
					</div>
				</form>
			</div>
		</div>
	    
		<div id="swipeContainer" class="swipe-container" style="display: none;">
			<div class="card-stack" id="cardStack">
			</div>
			<div id="noMoreProfiles" style="text-align: center; color: white; display: none;">
				<h2 class="text-2xl font-bold">Keine weiteren Profile gefunden 😢</h2>
				<p class="mt-2">Versuch es später noch einmal oder passe deine Sucheinstellungen an.</p>
			</div>
			<div class="swipe-actions">
				<button class="swipe-btn dislike" onclick="swipeCard('left')">❌</button>
				<button class="swipe-btn like" onclick="swipeCard('right')">💖</button>
			</div>
		</div>
	
		<div id="matchesContainer" class="flex flex-col bg-white p-6 rounded-lg shadow-xl w-full max-w-lg mx-auto" style="display: none;">
			<h2 class="text-2xl font-bold mb-4 text-gray-800 text-center">Deine Matches</h2>

			<!-- Liste der Matches -->
			<div id="matchesList" class="space-y-4 flex-1 overflow-auto">
				<p id="matchesLoading" class="text-gray-500 text-center">Lade Matches... 🔄</p>
			</div>

			<!-- Kein Matches Hinweis -->
			<div id="noMatches" class="text-center py-16 hidden">
				<div class="text-8xl mb-6">💔</div>
				<h3 class="text-2xl font-bold text-gray-700 mb-4">Noch keine Matches</h3>
				<p class="text-gray-500 mb-8 max-w-sm mx-auto">
					Keine Sorge! Swipe weiter nach rechts und finde deine perfekte Verbindung.
				</p>
			</div>

			<!-- Back / Swipe Button immer unten -->
			<div id="backToSwipe" class="mt-4 text-center hidden">
				<button onclick="showSwipeCards()" 
					class="bg-gradient-to-r from-purple-500 to-pink-500 text-white px-6 py-3 rounded-full hover:from-purple-600 hover:to-pink-600 transition-colors font-semibold">
					← Zurück zum Swipen
				</button>
			</div>
		</div>

		<!-- Template für einen Match (unsichtbar) -->
		<div id="matchTemplate" class="match-item hidden bg-white p-4 rounded-lg shadow-sm border border-gray-200 hover:shadow-md transition-shadow cursor-pointer mb-3">
			<div class="flex items-center space-x-4">
				<div class="flex-shrink-0 relative">
					<img class="w-16 h-16 rounded-full object-cover border-2 border-pink-200" src="" alt="">
				</div>
				<div class="flex-1 min-w-0">
					<h4 class="font-semibold text-lg text-gray-900 truncate">Name, ?</h4>
					<p class="text-sm text-gray-600 truncate">Noch keine Nachrichten</p>
					<span class="text-xs text-gray-400 bg-pink-100 px-2 py-1 rounded-full">💕 Match</span>
				</div>
			</div>
		</div>

		
		<div id="chatContainer" style="display:none;">
		    <div id="chatModal" data-chat-modal class="hidden fixed inset-0 bg-black bg-opacity-80 backdrop-blur-xl z-[2001] flex items-center justify-center p-5"> 
		        
		        <div id="chatBox" class="bg-gradient-to-br from-[#1e1e1e] to-[#2a2a2a] rounded-3xl max-w-md w-full h-[90vh] max-h-[800px] flex flex-col shadow-2xl overflow-hidden border border-gray-700/50"> 
		            
		            <div id="chatHeader" class="bg-gradient-to-r from-[#2d2d2d] to-[#3a3a3a] p-5 flex items-center justify-between rounded-t-3xl border-b border-gray-700/50 text-white">
		                
		                <div class="flex items-center space-x-4">
		                    <div class="relative">
		                         <img id="chatUserImage" src="/default-avatar.png" alt="" class="w-12 h-12 rounded-full object-cover border-4 border-gray-600/50 shadow-lg">
		                         <div class="absolute bottom-0 right-0 w-3 h-3 bg-green-400 rounded-full ring-2 ring-[#2a2a2a] shadow-md"></div>
		                    </div>
		
		                    <div>
		                        <h3 id="chatUserName" class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-white to-gray-300 mb-0.5"></h3>
		                        <div class="text-sm text-green-400">Online</div>
		                    </div>
		                </div>
		                
		                <div class="flex items-center space-x-3">
		                    <div id="aiBadge" class="hidden">
		                        <span class="ki-beta-branding font-semibold text-xs uppercase tracking-wider px-2 py-1 border border-white/20 rounded-xl">One-KI Beta</span>
		                    </div>
		                    <button id="reportChatBtn" class="p-2 rounded-full bg-white/10 hover:bg-white/20 text-white transition-all duration-300 backdrop-blur-sm border border-white/10">
		                         <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
		                    </button>
		                    <button id="closeChatBtn" class="p-2 rounded-full bg-white/10 hover:bg-white/20 text-white transition-all duration-300 backdrop-blur-sm border border-white/10">
		                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
		                    </button>
		                </div>
		            </div>
		            
		            <div id="chatMessages" class="flex-grow p-5 overflow-y-auto flex flex-col space-y-5 text-white">
		                </div>
		            
		            <div id="aiSuggestionsContainer" class="p-4 flex flex-wrap gap-2 justify-center border-t border-gray-700/50 bg-[#2d2d2d] hidden">
		                <div id="aiThinkingBubble" class="bg-white/10 p-3 rounded-xl border border-white/10 backdrop-blur-sm flex items-center space-x-2">
		                    <span id="typingText" class="ki-beta-branding text-sm text-gray-300"></span>
		                    <div class="typing-dots flex space-x-1">
		                        <div class="typing-dot w-1.5 h-1.5 rounded-full bg-indigo-400"></div>
		                        <div class="typing-dot w-1.5 h-1.5 rounded-full bg-indigo-400"></div>
		                        <div class="typing-dot w-1.5 h-1.5 rounded-full bg-indigo-400"></div>
		                    </div>
		                </div>
		            </div>
		            
		            <div class="p-5 bg-gradient-to-r from-[#2d2d2d] to-[#3a3a3a] rounded-b-3xl flex items-center space-x-4 border-t border-gray-700/50">
		                <input type="text" id="messageInput" placeholder="Schreibe eine Nachricht..." 
		                       class="flex-grow rounded-full py-3 px-5 text-base text-white border border-white/20 bg-white/10 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:bg-white/15 placeholder-gray-400 transition-all duration-300" 
		                       maxlength="500">
		                <button id="sendMessageBtn" class="bg-gradient-to-r from-indigo-500 to-purple-600 text-white rounded-full w-12 h-12 flex items-center justify-center shadow-lg shadow-indigo-500/30 hover:shadow-xl hover:shadow-indigo-500/40 transition-all duration-300">
		                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
		                </button>
		            </div>
		        </div>
		    </div>
		</div>


	
	<div id="profilePopup" class="profile-popup" style="display: none;">
		<div class="flex justify-between items-start mb-4">
			<h2 class="text-2xl font-bold shimmer" id="popupProfileName"></h2>
			<button onclick="closeProfilePopup()" class="text-gray-500 hover:text-gray-700 transition-colors">
				<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
				</svg>
			</button>
		</div>
		
		<div class="flex flex-col items-center">
			<img id="popupProfileImage" src="" alt="Profilbild" class="w-32 h-32 rounded-full object-cover mb-4">
			
			<!-- Distance und zusätzliche Info -->
			<p id="popupProfileDistance" class="text-gray-500 text-sm mb-2"></p>
			
			<!-- Zusätzliche Profil-Infos -->
			<div class="profile-additional-info">
				<div class="profile-info-row">
					<span class="profile-info-label">Geschlecht:</span>
					<span class="profile-info-value" id="popupProfileGender">-</span>
				</div>
				<div class="profile-info-row">
					<span class="profile-info-label">PLZ:</span>
					<span class="profile-info-value" id="popupProfilePostal">-</span>
				</div>
			</div>
			
			<!-- Description -->
			<p id="popupProfileDescription" class="text-gray-600 text-center mb-4"></p>
			
			<!-- Interests -->
			<div class="flex flex-wrap gap-2 justify-center mb-6" id="popupProfileInterests"></div>
			
			<!-- Q&A Section -->
			<div class="profile-qa-section" id="popupProfileQA">
				<div class="profile-qa-item" id="qa1Container" style="display: none;">
					<div class="profile-qa-question" id="popupPrompt1"></div>
					<div class="profile-qa-answer" id="popupAnswer1"></div>
				</div>
				<div class="profile-qa-item" id="qa2Container" style="display: none;">
					<div class="profile-qa-question" id="popupPrompt2"></div>
					<div class="profile-qa-answer" id="popupAnswer2"></div>
				</div>
			</div>
			
			<!-- Action Buttons -->
			<div class="flex space-x-4">
				<button onclick="editProfile()" class="bg-green-500 text-white font-bold py-2 px-4 rounded-lg shadow hover:bg-green-600 transition-colors">
					Profil bearbeiten
				</button>
				<button onclick="deleteProfile()" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg shadow hover:bg-red-600 transition-colors">
					Profil löschen
				</button>
			</div>
		</div>
	</div>
	
	
	<div id="loadingScreen" class="fixed inset-0 flex flex-col items-center justify-center z-[9999]">
	  <!-- Infinity Animation -->
	  <div class="infinity-loader">
		<svg width="200" height="100" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
		  <path d="M 50,50 C 50,20 100,20 100,50 C 100,80 150,80 150,50 C 150,20 100,20 100,50 C 100,80 50,80 50,50Z"
				fill="none" stroke="url(#chromeStroke)" stroke-width="6" stroke-linecap="round"/>
		  <path d="M 50,50 C 50,20 100,20 100,50 C 100,80 150,80 150,50 C 150,20 100,20 100,50 C 100,80 50,80 50,50Z"
				fill="none" stroke="url(#activeChromeStroke)" stroke-width="3" stroke-linecap="round" stroke-dasharray="30 20" stroke-dashoffset="0">
			<animate attributeName="stroke-dashoffset" values="0;-50;0" dur="3s" repeatCount="indefinite"/>
		  </path>
		  <path d="M 50,50 C 50,20 100,20 100,50 C 100,80 150,80 150,50 C 150,20 100,20 100,50 C 100,80 50,80 50,50Z"
				fill="none" stroke="url(#shineStroke)" stroke-width="10" stroke-linecap="round" stroke-dasharray="100 300" stroke-dashoffset="0" opacity="0.6">
			<animate attributeName="stroke-dashoffset" values="0;-400" dur="5s" repeatCount="indefinite"/>
		  </path>
		  <defs>
			<linearGradient id="chromeStroke" x1="0%" y1="0%" x2="100%" y2="100%">
			  <stop offset="0%" stop-color="#f8f9fa"/>
			  <stop offset="25%" stop-color="#dee2e6"/>
			  <stop offset="50%" stop-color="#adb5bd"/>
			  <stop offset="75%" stop-color="#6c757d"/>
			  <stop offset="100%" stop-color="#212529"/>
			</linearGradient>
			<linearGradient id="activeChromeStroke" x1="0%" y1="0%" x2="100%" y2="0%">
			  <stop offset="0%" stop-color="#ffffff">
				<animate attributeName="stop-color" values="#ffffff;#e9ecef;#ffffff" dur="3s" repeatCount="indefinite"/>
			  </stop>
			  <stop offset="100%" stop-color="#495057">
				<animate attributeName="stop-color" values="#495057;#212529;#495057" dur="3s" repeatCount="indefinite"/>
			  </stop>
			</linearGradient>
			<linearGradient id="shineStroke" x1="0%" y1="0%" x2="100%" y2="0%">
			  <stop offset="0%" stop-color="#ffffff" stop-opacity="0"/>
			  <stop offset="50%" stop-color="#ffffff" stop-opacity="1"/>
			  <stop offset="100%" stop-color="#ffffff" stop-opacity="0"/>
			</linearGradient>
		  </defs>
		</svg>
	  </div>
	  <p class="mt-4 text-gray-500">Lade Inhalte...</p>
	</div>
		

	<button id="profileButton" class="floating-button profile-button hidden" onclick="showProfilePopup()">
	    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>
	</button>
	<button id="chatButton" class="floating-button chat-button hidden" onclick="showMatches()">
	    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path></svg>
	</button>
</body>

    <!-- Notification -->
    <div id="notification" class="notification"></div>
	
	<script src="js/auth.js"></script>
	<script src="js/sidebar.js"></script>
	<script src="js/matches_system.js"></script>
	<script src="js/chat.js"></script>
	<script src="js/loading.js"></script>


	<script>
        // Global Variables
        let currentUser = null;
        let currentProfile = null;
        let sampleProfiles = [];
        let currentCardIndex = 0;
        let matches = [];
        let selectedPreferences = [];		
		let currentProfiles = [];
		let currentIndex = 0;
		let currentSwipeUser = null;
		let currentUserId = localStorage.getItem('currentUserId');
		let isSwipeInProgress = false;
		let selectedHobbies = [];
		let isUserPlus = false;
		let isAdmin = false;
		let lastSwipedProfile = null;
		let selectedGender = null;

	
		const emojiMap = {
			'alcohol': '🍷',
			'smoking': '🚬',
			'420': '🍁',
			'coffee': '☕',
			'none': '🚫'
		};

		const hobbiesMap = {
			'Kochen': '👩‍🍳',
			'Gaming': '🎮',
			'Wandern': '⛰️',
			'Fotografie': '📸',
			'Musik': '🎵',
			'Filme': '🎬',
			'Sport': '🏋️',
			'Kunst': '🎨',
			'Haustiere': '🐶',
			'Reisen': '🌍',
			'Essen & Trinken': '🍽️',
			'Lesen': '📚',
			'Technologie': '💻',
			'Kino': '🍿',
			'Strand': '🏖️',
			'Ausgehen': '🎉',
			'Konzerte': '🎤',
			'Sprachen': '🗣️',
			'Ehrenamt': '🤝',
			'Kultur': '🏛️',
			'Politik': '🗳️',
			'Natur': '🌲'
		};

		const apiUrl = 'https://onebenches.dpdns.org'; 
		
				
		// ---------------------------
		// AI Timer / Scheduler global + persistent via localStorage
		// ---------------------------
		window.aiReplyTimers = window.aiReplyTimers || {};

		function persistTimerToStorage(convId, meta) {
		  try {
			localStorage.setItem(`ai_timer_${convId}`, JSON.stringify(meta));
		  } catch (e) {}
		}
		function removeTimerFromStorage(convId) {
		  try { localStorage.removeItem(`ai_timer_${convId}`); } catch (e) {}
		}

		function restoreAiTimers() {
		  try {
			Object.keys(localStorage).forEach(k => {
			  if (!k.startsWith('ai_timer_')) return;
			  const convId = k.replace('ai_timer_', '');
			  const meta = JSON.parse(localStorage.getItem(k) || '{}');
			  if (!meta || !meta.dueAt) {
				removeTimerFromStorage(convId);
				return;
			  }
			  const remaining = Math.max(meta.dueAt - Date.now(), 0);
			  if (window.aiReplyTimers[convId] && window.aiReplyTimers[convId].id) return;

			  window.aiReplyTimers[convId] = {
				pendingUserMessages: meta.pendingUserMessages || [],
				dueAt: meta.dueAt,
				id: setTimeout(() => triggerAiReply(convId), remaining)
			  };
			});
		  } catch (e) { console.error('restoreAiTimers error', e); }
		}

		document.addEventListener('DOMContentLoaded', () => {
		  restoreAiTimers();
		});
		
        // Navigation Functions
        function showWelcome() {
            hideAllScreens();
            document.getElementById('welcomeScreen').style.display = 'block';
        }

        function showProfileCreation() {
            if (!currentUser) {
                showLogin();
                showNotification('🔒 Sie müssen sich anmelden, um ein Profil zu erstellen!', 'error');
                return;
            }
            hideAllScreens();
            document.getElementById('profileCreation').style.display = 'block';
        }
		
		function showCreateProfileForm() {
		    closeProfilePopup(); // Stellt sicher, dass das Popup geschlossen ist
		    document.getElementById('createProfileSection').style.display = 'none';
		    document.getElementById('createProfileModal').style.display = 'block';
		    // Optional: Leeren Sie hier das Formular, falls nötig
		}

		function closeCreateProfile() {
			document.getElementById('createProfileSection').style.display = 'flex';
			document.getElementById('createProfileModal').style.display = 'none';
			
			// NEUE ZEILE: Zurück zum Swipe-Container wenn Profil existiert
			if (currentProfile) {
				checkAndRenderUI();
			}
		}
		// Verbesserte Error-Behandlung für alle API-Calls
		async function safeApiCall(url, options, fallbackMessage) {
		    try {
		        const response = await fetch(url, options);
		        
		        if (!response.ok) {
		            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
		        }
		        
		        const result = await response.json();
		        return { success: true, data: result };
		        
		    } catch (error) {
		        console.error('API Call failed:', error);
		        showNotification(fallbackMessage || 'Ein Fehler ist aufgetreten', 'error');
		        return { success: false, error: error.message };
		    }
		}
		
		async function showProfilePopup() {
			if (!currentUser || !currentUser.uid) {
				showNotification('❌ Bitte melden Sie sich erneut an.', 'error');
				return;
			}
			
			try {
				const response = await fetch('/.netlify/functions/get_my_profile', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});

				const result = await response.json();

				if (response.ok && result.profile) {
					currentProfile = result.profile;

					// Name + Alter
					const nameText = currentProfile.profile_name || 'Unbekannt';
					const ageText = currentProfile.age ? `, ${currentProfile.age}` : '';
					document.getElementById('popupProfileName').textContent = nameText + ageText;

					// Profilbild
					document.getElementById('popupProfileImage').src = currentProfile.profile_image || '/default-avatar.jpg';
					
					// Beschreibung
					document.getElementById('popupProfileDescription').textContent = currentProfile.description || 'Keine Beschreibung verfügbar.';

					// Entfernung berechnen
					let distanceText = '';
					if (currentProfile.latitude && currentProfile.longitude && currentUser.latitude && currentUser.longitude) {
						const dist = calculateDistance(
							currentUser.latitude, currentUser.longitude,
							currentProfile.latitude, currentProfile.longitude
						);
						distanceText = `${dist} km entfernt`;
					}
					document.getElementById('popupProfileDistance').textContent = distanceText;
					document.getElementById('popupProfileDistance').style.display = distanceText ? 'block' : 'none';

					// Zusätzliche Infos
					document.getElementById('popupProfileGender').textContent = currentProfile.gender || 'Nicht angegeben';
					document.getElementById('popupProfilePostal').textContent = currentProfile.postal_code || 'Nicht angegeben';

					// Interessen
					const interestsDiv = document.getElementById('popupProfileInterests');
					interestsDiv.innerHTML = '';
					const allEmojis = {
						'alcohol': '🍷', 'smoking': '🚬', '420': '🍁', 'coffee': '☕', 'none': '🚫',
						'Sport': '🏋️', 'Musik': '🎵', 'Reisen': '🌍', 'Essen & Trinken': '🍽️', 
						'Lesen': '📚', 'Gaming': '🎮', 'Filme': '🎬', 'Serien': '📺',
						'Kochen': '👩‍🍳', 'Wandern': '⛰️', 'Fotografie': '📸', 'Tanzen': '💃', 
						'Kunst': '🎨', 'Fitness': '💪', 'Yoga': '🧘', 'Meditation': '🧘‍♂️',
						'Gartenarbeit': '🧑‍🌾', 'Tiere': '🐾', 'Shopping': '🛍️', 
						'Technologie': '💻', 'Bücher': '📖', 'Kino': '🍿', 'Strand': '🏖️',
						'Ausgehen': '🎉', 'Konzerte': '🎤', 'Sprachen': '🗣️', 'Ehrenamt': '🤝', 
						'Kultur': '🏛️', 'Politik': '🗳️', 'Natur': '🌲'
					};
					
					const interests = Array.isArray(currentProfile.interests) ? currentProfile.interests : 
									 (currentProfile.interests ? JSON.parse(currentProfile.interests) : []);
					
					interests.forEach(interest => {
						const span = document.createElement('span');
						const emoji = allEmojis[interest] || '❓';
						span.textContent = `${emoji} ${interest}`;
						span.className = 'px-3 py-1 bg-gray-200 text-gray-700 rounded-full text-sm font-medium mr-2 mb-2 inline-block';
						interestsDiv.appendChild(span);
					});

					// Q&A Bereiche
					const qa1Container = document.getElementById('qa1Container');
					const qa2Container = document.getElementById('qa2Container');
					
					if (currentProfile.prompt_1 && currentProfile.answer_1) {
						document.getElementById('popupPrompt1').textContent = currentProfile.prompt_1;
						document.getElementById('popupAnswer1').textContent = currentProfile.answer_1;
						qa1Container.style.display = 'block';
					} else {
						qa1Container.style.display = 'none';
					}
					
					if (currentProfile.prompt_2 && currentProfile.answer_2) {
						document.getElementById('popupPrompt2').textContent = currentProfile.prompt_2;
						document.getElementById('popupAnswer2').textContent = currentProfile.answer_2;
						qa2Container.style.display = 'block';
					} else {
						qa2Container.style.display = 'none';
					}

					// Modal anzeigen
					document.getElementById('profilePopup').style.display = 'block';
					document.getElementById('modalOverlay').style.display = 'block';
					
				} else {
					showNotification('❌ Fehler beim Laden des Profils: ' + (result.error || 'Unbekannter Fehler'), 'error');
				}
			} catch (error) {
				console.error('Fehler beim Anzeigen des Profil-Popups:', error);
				showNotification('Ein Fehler ist aufgetreten: ' + error.message, 'error');
			}
		}
		
		function closeProfilePopup() {
			document.getElementById('profilePopup').style.display = 'none';
			document.getElementById('modalOverlay').style.display = 'none';
		}
				
		async function editProfile() {
			if (!currentProfile) {
				showNotification('❌ Profil-Daten nicht verfügbar', 'error');
				return;
			}

			try {
				// Nicht editierbare Felder (readonly)
				const nameInput = document.getElementById('profileName');
				if (nameInput) {
					nameInput.value = currentProfile.profile_name || '';
					nameInput.readOnly = true;
				}

				const ageInput = document.getElementById('profileAge');
				if (ageInput) {
					ageInput.value = currentProfile.age || '';
					ageInput.readOnly = true;
				}

				// Editierbare Felder
				const descriptionInput = document.getElementById('profileDescription');
				if (descriptionInput) {
					descriptionInput.value = currentProfile.description || '';
				}

				const postalCodeInput = document.getElementById('postalCode');
				if (postalCodeInput) {
					postalCodeInput.value = currentProfile.postal_code || '';
				}

				const interests = Array.isArray(currentProfile.interests)
					? currentProfile.interests
					: (currentProfile.interests ? [currentProfile.interests] : []);

				const preferencesOptions = ['wine', '420', 'coffee', 'book', 'bike'];
				const hobbiesOptions = ['Kochen', 'Gaming', 'Wandern', 'Fotografie', 'Musik', 'Filme', 'Sport', 'Kunst', 'Haustiere'];

				selectedPreferences = interests.filter(i => preferencesOptions.includes(i));
				selectedHobbies = interests.filter(i => hobbiesOptions.includes(i));

				renderPreferences();
				renderHobbies();

				if (currentProfile.prompt_1) {
					const prompt1Select = document.getElementById('prompt1Select');
					const answer1Input = document.getElementById('answer1Input');
					if (prompt1Select) prompt1Select.value = currentProfile.prompt_1;
					if (answer1Input) answer1Input.value = currentProfile.answer_1 || '';
				}

				if (currentProfile.prompt_2) {
					const prompt2Select = document.getElementById('prompt2Select');
					const answer2Input = document.getElementById('answer2Input');
					if (prompt2Select) prompt2Select.value = currentProfile.prompt_2;
					if (answer2Input) answer2Input.value = currentProfile.answer_2 || '';
				}

				closeProfilePopup();
				showCreateProfileForm();

				// Formular-Anpassungen
				document.getElementById('createProfileSection').style.display = 'none';
				const formTitle = document.querySelector('#createProfileModal h2');
				if (formTitle) formTitle.textContent = '✏️ Profil bearbeiten';

				const submitBtn = document.querySelector('#createProfileModal button[type="submit"]');
				if (submitBtn) submitBtn.innerHTML = '💾 Änderungen speichern';
				// Gender komplett ausblenden beim Edit
				const genderGroup = document.querySelector('.form-group label + .gender-selection')?.parentElement;
				if (genderGroup) {
				    genderGroup.style.display = 'none';
				}

			} catch (error) {
				console.error('Fehler beim Bearbeiten:', error);
				showNotification('Fehler beim Laden der Profil-Daten', 'error');
			}
		}



		function renderPreferences() {
		    const preferencesDiv = document.getElementById('preferencesIcons');
		    if (preferencesDiv) {
		        preferencesDiv.innerHTML = ''; // Vorherige Icons leeren
		        
		        // Definiere verfügbare Präferenzen mit ihren Emojis
		        const preferencesOptions = {
					'alcohol': '🍷',
					'smoking': '🚬',
					'420': '🍁',
					'coffee': '☕',
					'none': '🚫'
		        };
		        
		        Object.entries(preferencesOptions).forEach(([pref, emoji]) => {
		            const isSelected = selectedPreferences.includes(pref) ? 'selected' : '';
		            const option = document.createElement('div');
		            option.className = `preference-option ${isSelected}`;
		            option.dataset.value = pref; // WICHTIG: data-value setzen
		            option.setAttribute('onclick', `togglePreference(this, '${pref}')`);
		            option.innerHTML = `<span>${emoji}</span><div class="tooltip">${pref}</div>`;
		            preferencesDiv.appendChild(option);
		        });
		    }
		}		

		// Ihre neue Render-Funktion für Hobbies
		function renderHobbies() {
		    const hobbiesDiv = document.getElementById('hobbiesIcons');
		    if (!hobbiesDiv) return;
		    
		    hobbiesDiv.innerHTML = ''; 
		    
		    const hobbiesOptions = {
				'Kochen': '👩‍🍳',
				'Gaming': '🎮',
				'Wandern': '⛰️',
				'Fotografie': '📸',
				'Musik': '🎵',
				'Filme': '🎬',
				'Sport': '🏋️',
				'Kunst': '🎨',
				'Haustiere': '🐶',
				'Reisen': '🌍',
				'Essen & Trinken': '🍽️',
				'Lesen': '📚',
				'Technologie': '💻',
				'Kino': '🍿',
				'Strand': '🏖️',
				'Ausgehen': '🎉',
				'Konzerte': '🎤',
				'Sprachen': '🗣️',
				'Ehrenamt': '🤝',
				'Kultur': '🏛️',
				'Politik': '🗳️',
				'Natur': '🌲'
		    };
		    
		    Object.entries(hobbiesOptions).forEach(([hobby, emoji]) => {
		        const isSelected = selectedHobbies.includes(hobby) ? 'selected' : '';
		        const option = document.createElement('div');
		        option.className = `preference-option ${isSelected}`;
		        option.dataset.value = hobby; // WICHTIG: data-value setzen
		        option.setAttribute('onclick', `toggleHobby(this, '${hobby}')`);
		        option.innerHTML = `<span>${emoji}</span><div class="tooltip">${hobby}</div>`;
		        hobbiesDiv.appendChild(option);
		    });
		}
		
		// Ihre neue Funktion zum Umschalten der Hobbies mit Limit
		function toggleHobby(element, hobby) {
		    const maxHobbies = 5;
		    if (selectedHobbies.includes(hobby)) {
		        selectedHobbies = selectedHobbies.filter(h => h !== hobby);
		        element.classList.remove('selected');
		    } else {
		        if (selectedHobbies.length < maxHobbies) {
		            selectedHobbies.push(hobby);
		            element.classList.add('selected');
		        } else {
		            alert(`Du kannst maximal ${maxHobbies} Hobbies auswählen.`);
		        }
		    }
		}		

		async function deleteProfile() {
		    if (!confirm("Sind Sie sicher, dass Sie Ihr Profil löschen möchten?")) {
		        return;
		    }
		    try {
		        const response = await fetch('/.netlify/functions/delete_profile', {
		            method: 'DELETE',
		            headers: { 'Content-Type': 'application/json' },
		            body: JSON.stringify({ userId: currentUser.uid })
		        });
		
		        // Überprüfen Sie den Statuscode, bevor Sie die Antwort parsen
		        if (response.ok) {
		            const result = await response.json();
		            if (result.success) {
		                showNotification('✅ Profil erfolgreich gelöscht!', 'success');
		                closeProfilePopup();
		                checkAndRenderUI();
						window.location.reload(); 
		            } else {
		                showNotification('❌ Fehler beim Löschen des Profils: ' + result.error, 'error');
		            }
		        } else {
		            // Wenn die Antwort nicht erfolgreich ist, verarbeiten Sie den Fehlertext
		            const errorText = await response.text();
		            showNotification('❌ Fehler beim Löschen des Profils: ' + errorText, 'error');
		        }
		    } catch (error) {
		        showNotification('Ein Fehler ist aufgetreten: ' + error.message, 'error');
		    }
		}
		
		async function checkAndRenderUI() {
			hideAllScreens();

			if (!currentUser || !currentUser.uid) {
				// Zustand: Nicht angemeldet
				document.getElementById('welcomeScreen').style.display = 'block';
				updateFloatingButtons();
				document.body.style.overflow = 'auto';
				
				hideLoadingScreen(); // 👈 Loader auch hier ausblenden
				return;
			}

			document.body.style.overflow = 'hidden';

			try {
				const response = await fetch('/.netlify/functions/check_profile', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});

				const result = await response.json();

				if (result.hasProfile) {
					showSwipeCards();
					await initializeUserPlusFeatures();
					await loadProfiles();
				} else {
					showCreateProfileSection();
					updateFloatingButtons();
				}
			} catch (error) {
				console.error('Fehler beim Prüfen des Profils:', error);
				showNotification('⚠️ Fehler beim Laden. Bitte versuchen Sie es erneut.', 'error');
				document.getElementById('welcomeScreen').style.display = 'block';
				updateFloatingButtons();
				document.body.style.overflow = 'auto';
			} finally {
				// ✅ Egal ob Erfolg oder Fehler → Loader verschwindet
				hideLoadingScreen();
			}
		}

		
		// ✅ NEW: Unified function to show "no more profiles" message
		function showNoMoreProfilesInCardStack() {
			const cardStack = document.getElementById('cardStack');
			const swipeActions = document.querySelector('.swipe-actions');
			const backButtonContainer = document.querySelector('div[style*="text-align: center; margin-top: 20px;"]');
			
			const floatingButtons = document.querySelector('.floating-buttons');
			if (floatingButtons) floatingButtons.style.display = 'none';
			
			// Set cardStack to use the same positioning as loadSwipeCards
			cardStack.style.cssText = '';
			cardStack.innerHTML = `
			  <div class="flex flex-col items-center justify-center h-full text-center space-y-4">

				<!-- Headline -->
				<h3 class="text-xl font-semibold text-gray-800">
				  Keine weiteren Profile gefunden
				</h3>

				<!-- Infinity Symbol (wie Loader, nur ohne rotation) -->
				<div class="infinity-loader" style="animation: none;">
				  <svg width="200" height="100" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
					<!-- Main infinity path -->
					<path d="M 50,50 C 50,20 100,20 100,50 C 100,80 150,80 150,50 C 150,20 100,20 100,50 C 100,80 50,80 50,50Z"
						  fill="none"
						  stroke="url(#chromeStroke)"
						  stroke-width="6"
						  stroke-linecap="round"/>
					
					<!-- Animated dash stroke -->
					<path d="M 50,50 C 50,20 100,20 100,50 C 100,80 150,80 150,50 C 150,20 100,20 100,50 C 100,80 50,80 50,50Z"
						  fill="none"
						  stroke="url(#activeChromeStroke)"
						  stroke-width="3"
						  stroke-linecap="round"
						  stroke-dasharray="30 20"
						  stroke-dashoffset="0">
					  <animate attributeName="stroke-dashoffset" values="0;-50;0" dur="3s" repeatCount="indefinite"/>
					</path>

					<!-- Shine sweep -->
					<path d="M 50,50 C 50,20 100,20 100,50 C 100,80 150,80 150,50 C 150,20 100,20 100,50 C 100,80 50,80 50,50Z"
						  fill="none"
						  stroke="url(#shineStroke)"
						  stroke-width="10"
						  stroke-linecap="round"
						  stroke-dasharray="100 300"
						  stroke-dashoffset="0"
						  opacity="0.6">
					  <animate attributeName="stroke-dashoffset" values="0;-400" dur="5s" repeatCount="indefinite"/>
					</path>

					<defs>
					  <!-- Chrome Basis-Stroke -->
					  <linearGradient id="chromeStroke" x1="0%" y1="0%" x2="100%" y2="100%">
						<stop offset="0%" stop-color="#f8f9fa"/>
						<stop offset="25%" stop-color="#dee2e6"/>
						<stop offset="50%" stop-color="#adb5bd"/>
						<stop offset="75%" stop-color="#6c757d"/>
						<stop offset="100%" stop-color="#212529"/>
					  </linearGradient>

					  <!-- Active chrome stroke -->
					  <linearGradient id="activeChromeStroke" x1="0%" y1="0%" x2="100%" y2="0%">
						<stop offset="0%" stop-color="#ffffff">
						  <animate attributeName="stop-color" values="#ffffff;#e9ecef;#ffffff" dur="3s" repeatCount="indefinite"/>
						</stop>
						<stop offset="100%" stop-color="#495057">
						  <animate attributeName="stop-color" values="#495057;#212529;#495057" dur="3s" repeatCount="indefinite"/>
						</stop>
					  </linearGradient>

					  <!-- Shine stroke -->
					  <linearGradient id="shineStroke" x1="0%" y1="0%" x2="100%" y2="0%">
						<stop offset="0%" stop-color="#ffffff" stop-opacity="0"/>
						<stop offset="50%" stop-color="#ffffff" stop-opacity="1"/>
						<stop offset="100%" stop-color="#ffffff" stop-opacity="0"/>
					  </linearGradient>
					</defs>
				  </svg>
				</div>

				<!-- Subline -->
				<p class="text-gray-500 text-sm">
				  Versuche es später erneut
				</p>

				<!-- Button -->
				<button onclick="reloadProfiles()" 
				  class="mt-4 bg-gradient-to-r from-gray-800 to-gray-600 text-white px-8 py-3 rounded-full shadow-lg hover:from-gray-900 hover:to-gray-700 transition">
				  Erneut versuchen
				</button>
			  </div>
			`;
						
			// ✅ FIX: Make sure floating buttons are visible
			updateFloatingButtons();
		}
				
		
		async function loadProfiles() {
			console.log('🔄 Profile werden geladen...');
			const cardStack = document.getElementById('cardStack');
			if (!cardStack) {
				console.log('cardStack noch nicht bereit, versuche erneut...');
				setTimeout(loadProfiles, 100);
				return;
			}
			try {
				// Get both profiles and existing matches
				const [profilesResponse, matchesResponse] = await Promise.all([
					fetch('/.netlify/functions/get_profile', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ userId: currentUser.uid })
					}),
					fetch('/.netlify/functions/get_matches', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ userId: currentUser.uid })
					})
				]);
				
				const profilesResult = await profilesResponse.json();
				const matchesResult = await matchesResponse.json();
				
				// Lokale Matches laden (für AI-Profile)
				let localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
				
				const matchedUserIds = matchesResult.success && matchesResult.matches 
					? matchesResult.matches
						.filter(m => !m.isAI)
						.map(m => m.matched_user_id || m.user_id)
					: [];

				// KORRIGIERT: Bereits gematchte AI-Profile-IDs extrahieren
				const matchedAIProfileIds = localMatches
					.filter(m => m.isAI && m.ai_profile_id) // ai_profile_id muss existieren
					.map(m => m.ai_profile_id); // Echte AI-Profile-ID, nicht match_id
					  
				// --- Echte Profile ---
				let realProfiles = [];
				if (profilesResponse.ok && profilesResult.success && profilesResult.profiles) {
					realProfiles = profilesResult.profiles.filter(p => 
						p.user_id !== currentUser.uid && 
						!matchedUserIds.includes(p.user_id)
					);
				}
				
				// --- AI Profile ---
				let aiProfiles = [];
				if (realProfiles.length < 5) {
					const myProfile = JSON.parse(localStorage.getItem('currentProfile') || '{}');
					const userGender = myProfile.gender;
					const targetGender = userGender === 'male' ? 'female' : 'male';
					
					try {
						const res = await fetch('/.netlify/functions/generate_ai_profiles');
						const data = await res.json();
						aiProfiles = data.profiles
							.filter(p => p.gender === targetGender)
							.filter(p => !matchedAIProfileIds.includes(p.id)) // KORRIGIERT: Echte ID-Vergleich
							.map(p => ({ ...p, isAI: true })); // ID bleibt original
					} catch (err) {
						console.error("Fehler beim Laden der AI-Profile:", err);
					}
				}
				
				const allProfiles = [...realProfiles, ...aiProfiles];
				currentProfiles = allProfiles;
				
				if (currentProfiles.length > 0) {
					console.log(`🎯 ${currentProfiles.length} Profile geladen (${realProfiles.length} echt, ${currentProfiles.length - realProfiles.length} KI)`);
					currentIndex = 0;
					renderSwipeCards();
					
					const floatingButtons = document.querySelector('.floating-buttons');
					if (floatingButtons) floatingButtons.style.display = 'flex';
				} else {
					showNoMoreProfilesInCardStack();
				}
			} catch (error) {
				console.error('Fehler beim Laden der Profile:', error);
				showNoMoreProfilesInCardStack();
			}		
		}
		
		function showCreateProfileSection() {
			hideAllScreens();
			document.getElementById('createProfileSection').style.display = 'flex';
		}
		
		function showSwipeCards() {
			hideAllScreens();
			stopMatchesAutoRefresh();
			const swipeContainer = document.getElementById('swipeContainer');
			swipeContainer.style.display = 'block';
			
			// Ensure the cardStack is properly centered
			const cardStack = document.getElementById('cardStack');
			if (cardStack) {
				cardStack.style.display = 'flex';
				cardStack.style.alignItems = 'center';
				cardStack.style.justifyContent = 'center';
				cardStack.style.minHeight = '60vh';
			}
			
			document.getElementById('noMoreProfiles').style.display = 'none';
		}


		function hideAllScreens() {
		    // Fügen Sie hier alle IDs Ihrer Haupt-Bildschirme hinzu,
		    // die beim Start ausgeblendet werden sollen.
		    const screens = [
		        'welcomeScreen', 
		        'createProfileSection', 
		        'createProfileModal', 
		        'matchesContainer', 
		        'profilePopup'
		    ];
		    
		    screens.forEach(id => {
		        const element = document.getElementById(id);
		        if (element) { // Wichtige Prüfung, ob das Element existiert
		            element.style.display = 'none';
		        }
		    });
		}

        // Profile Creation Functions
		function togglePreference(element, pref) {
			if (selectedPreferences.includes(pref)) {
				selectedPreferences = selectedPreferences.filter(p => p !== pref);
				element.classList.remove('selected');
			} else {
				selectedPreferences.push(pref);
				element.classList.add('selected');
			}
		}

		async function createProfile(event) {
			event.preventDefault();

			if (!currentUser || !currentUser.uid) {
				showNotification('❌ Fehler: Bitte melden Sie sich erneut an.', 'error');
				return;
			}

			const name = document.getElementById('profileName').value;
			const age = document.getElementById('profileAge').value;
			const description = document.getElementById('profileDescription').value;
			const imageFile = document.getElementById('profileImage').files[0];
			const postalCode = document.getElementById('postalCode').value;
			const prompt1 = document.getElementById('prompt1Select').value;
			const answer1 = document.getElementById('answer1Input').value;
			const prompt2 = document.getElementById('prompt2Select').value;
			const answer2 = document.getElementById('answer2Input').value;
			const gender = selectedGender; 
			
			if (!imageFile) {
				showNotification('Bitte wählen Sie ein Profilbild aus!', 'error');
				return;
			}

			if (!age || age < 18 || age > 99) {
				showNotification('Bitte geben Sie ein gültiges Alter ein (18-99)!', 'error');
				return;
			}

			if ((prompt1 && !answer1) || (prompt2 && !answer2)) {
				showNotification('Bitte beantworte deine ausgewählten Fragen.', 'error');
				return;
			}

			let coordinates = null;
			try {
				coordinates = await getCoordinatesFromPostalCode(postalCode);
			} catch (error) {
				console.warn('GPS-Koordinaten konnten nicht ermittelt werden:', error);
			}

			const selectedGenussmittel = Array.from(document.querySelectorAll('#preferencesIcons .selected'))
				.map(el => el.dataset.value)
				.filter(val => val);

			const selectedHobbiesFromUI = Array.from(document.querySelectorAll('#hobbiesIcons .selected'))
				.map(el => el.dataset.value)
				.filter(val => val);

			const allInterests = [...selectedGenussmittel, ...selectedHobbiesFromUI];

			try {
				const profileImageUrl = await uploadImageToCloudinary(imageFile);

				const profileData = {
					userId: currentUser.uid, 
					name: name,
					age: parseInt(age),
					description: description,
					interests: allInterests,
					profileImage: profileImageUrl,
					postalCode: postalCode,
					latitude: coordinates?.lat || null,
					longitude: coordinates?.lng || null,
					prompt1: prompt1,
					answer1: answer1,
					prompt2: prompt2,
					answer2: answer2,
					gender: selectedGender // 👈 an Backend senden
				};

				console.log('📤 Sende Profil-Daten:', profileData);

				const response = await fetch('/.netlify/functions/create_profile', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(profileData)
				});

				const result = await response.json();

				if (response.ok && result.success) {
					currentProfile = {
						id: result.profileId,
						name: name,
						age: age,
						description: description,
						interests: allInterests,
						profileImage: profileImageUrl,
						latitude: coordinates?.lat,
						longitude: coordinates?.lng,
						gender: selectedGender // 👈 auch lokal speichern
					};
					localStorage.setItem('currentProfile', JSON.stringify(currentProfile));

					showNotification('✅ Profil erfolgreich erstellt!', 'success');
					checkAndRenderUI();
				} else {
					showNotification('❌ Fehler beim Speichern des Profils: ' + result.error, 'error');
				}

			} catch (error) {
				console.error('Fehler beim Erstellen des Profils:', error);
				showNotification('Ein Fehler ist aufgetreten: ' + error.message, 'error');
			}
		}


		// NEW: Function to get coordinates from postal code
		async function getCoordinatesFromPostalCode(postalCode) {
			try {
				// Using OpenStreetMap Nominatim API (free alternative to Google Maps)
				const response = await fetch(
					`https://nominatim.openstreetmap.org/search?format=json&countrycodes=de&postalcode=${postalCode}&limit=1`
				);
				
				const data = await response.json();
				
				if (data && data.length > 0) {
					return {
						lat: parseFloat(data[0].lat),
						lng: parseFloat(data[0].lon)
					};
				} else {
					throw new Error('Postleitzahl nicht gefunden');
				}
			} catch (error) {
				console.error('Geocoding Fehler:', error);
				throw error;
			}
		}

		// NEW: Function to calculate distance between two coordinates
		function calculateDistance(lat1, lon1, lat2, lon2) {
			const R = 6371; // Earth's radius in kilometers
			const dLat = (lat2 - lat1) * Math.PI / 180;
			const dLon = (lon2 - lon1) * Math.PI / 180;
			const a = 
				Math.sin(dLat/2) * Math.sin(dLat/2) +
				Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
				Math.sin(dLon/2) * Math.sin(dLon/2);
			const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
			const distance = R * c;
			return Math.round(distance);
		}

		function generateSampleProfiles() {
			sampleProfiles = [
				{
					id: 1,
					name: "Anna",
					age: 26,
					gender: "female",
					description: "Liebe Spaziergänge in der Natur und romantische Sonnenuntergänge auf Bänken 🌅 Suche jemanden für tiefe Gespräche bei einem Glas Wein.",
					image: "https://images.unsplash.com/photo-1699474072277-aeccb6e17263?q=80&w=2061&auto=format&fit=crop",
					preferences: ["wine", "Wandern", "Fotografie"],
					latitude: 49.0069 + (Math.random() - 0.5) * 0.1,
					longitude: 8.4037 + (Math.random() - 0.5) * 0.1
				},
				{
					id: 2,
					name: "Max",
					age: 29,
					gender: "male",
					description: "Entspannte Gespräche bei einem Glas Wein sind das Beste! 🍷 Musik-Liebhaber der gerne chillt und das Leben genießt.",
					image: "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=400&fit=crop&crop=face",
					preferences: ["wine", "420", "Musik"],
					latitude: 49.0069 + (Math.random() - 0.5) * 0.1,
					longitude: 8.4037 + (Math.random() - 0.5) * 0.1
				},
				{
					id: 3,
					name: "Lisa",
					age: 24,
					gender: "female",
					description: "Naturliebhaberin, die gerne neue Orte entdeckt und chillige Momente genießt 🍃 Bin immer für spontane Abenteuer zu haben!",
					image: "https://images.unsplash.com/photo-1438761681033-6461ffad8d80?w=400&h=400&fit=crop&crop=face",
					preferences: ["420", "Wandern", "Haustiere"],
					latitude: 49.0069 + (Math.random() - 0.5) * 0.1,
					longitude: 8.4037 + (Math.random() - 0.5) * 0.1
				},
				{
					id: 4,
					name: "Tom",
					age: 31,
					gender: "male",
					description: "Romantiker mit Herz für schöne Aussichten und tiefe Gespräche 💕 Kunst und Kultur sind meine Leidenschaft.",
					image: "https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=400&h=400&fit=crop&crop=face",
					preferences: ["wine", "Kunst", "Musik"],
					latitude: 49.0069 + (Math.random() - 0.5) * 0.1,
					longitude: 8.4037 + (Math.random() - 0.5) * 0.1
				},
				{
					id: 5,
					name: "Sarah",
					age: 27,
					gender: "female",
					description: "Lebenslustig und immer für Abenteuer zu haben! Lass uns die Welt entdecken 🌍 Sport, Filme und gute Vibes!",
					image: "https://images.unsplash.com/photo-1544005313-94ddf0286df2?w=400&h=400&fit=crop&crop=face",
					preferences: ["wine", "420", "Sport", "Filme"],
					latitude: 49.0069 + (Math.random() - 0.5) * 0.1,
					longitude: 8.4037 + (Math.random() - 0.5) * 0.1
				}
			];
		}

		// Swipe Functions
		function createSwipeCardFromData(profile) {
		    const cardHtml = `
		        <div class="swipe-card" data-user-id="${profile.user_id}">
		            <img src="${profile.profile_image || profile.image}" alt="${profile.profile_name || profile.name}" >
		            <div class="card-content">
		                <div>
		                    <h3 class="card-name">${profile.profile_name || profile.name}</h3>
		                    <p class="card-description">${profile.description || ''}</p>
		                </div>
		                <div class="card-preferences">
		                    ${(profile.interests || []).map(interest => `<span class="preference-icon">${emojiMap[interest] || ''}</span>`).join('')}
		                </div>
		            </div>
		        </div>
		    `;
		    return cardHtml;
		}

		function renderSwipeCards() {
			const cardStack = document.getElementById('cardStack');
			if (!cardStack) {
				console.error("cardStack Element nicht gefunden!");
				return;
			}
			
			// Reset cardStack to normal positioning for cards
			cardStack.style.cssText = '';
			cardStack.innerHTML = '';

			if (!currentProfiles || currentProfiles.length === 0) {
				showNoMoreCards();
				return;
			}

			// Erstelle die Karten, da Profile vorhanden sind
			const maxCards = Math.min(3, currentProfiles.length - currentIndex);
			for (let i = 0; i < maxCards; i++) {
				const profile = currentProfiles[currentIndex + i];
				createSwipeCard(profile, i);
			}
			
			updateFloatingButtons();
		}
		
			// Verbesserte loadSwipeCards mit Error Handling
		async function loadSwipeCards() {
			console.log('🔄 loadSwipeCards aufgerufen');
			
			let cardStack = document.getElementById('cardStack');
			if (!cardStack) {
				console.warn('⚠️ cardStack noch nicht bereit, versuche erneut...');
				setTimeout(loadSwipeCards, 100);
				return;
			}

			cardStack.innerHTML = '<div class="text-center p-8"><div class="text-4xl mb-4">🔄</div><p>Lade Profile...</p></div>';
			
			try {
				const response = await fetch('/.netlify/functions/get_profile', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});
				const result = await response.json();

				if (result.success && result.data && result.data.profiles) {
					currentProfiles = result.data.profiles.filter(p => p.user_id !== currentUser.uid);
					currentIndex = 0;
					
					console.log(`🎯 ${currentProfiles.length} Profile geladen`);
					
					if (currentProfiles.length > 0) {
						requestAnimationFrame(() => renderSwipeCards());
					} else {
						// Diese Anzeige kommt, wenn die API-Verbindung erfolgreich war,
						// aber keine Profile geladen wurden.
						cardStack.innerHTML = `
							<div class="text-center p-12 flex flex-col items-center justify-center h-full">
								<div class="text-6xl mb-4">😞</div>
								<h3 class="text-xl font-bold text-gray-700 mb-2">Laden fehlgeschlagen</h3>
								<p class="text-gray-500 mb-6">Profile konnten nicht geladen werden.</p>
								<button onclick="loadSwipeCards()" class="bg-blue-500 text-white px-6 py-3 rounded-full hover:bg-blue-600">
									🔄 Erneut versuchen
								</button>
							</div>
						`;
					}
				} else {
					// Dies ist der Block für einen echten Fehler von der API.
					// Er zeigt die gleiche Anzeige, wie du es wolltest.
					cardStack.innerHTML = `
						<div class="text-center p-12 flex flex-col items-center justify-center h-full">
							<div class="text-6xl mb-4">😞</div>
							<h3 class="text-xl font-bold text-gray-700 mb-2">Laden fehlgeschlagen</h3>
							<p class="text-gray-500 mb-6">Profile konnten nicht geladen werden.</p>
							<button onclick="loadSwipeCards()" class="bg-blue-500 text-white px-6 py-3 rounded-full hover:bg-blue-600">
								🔄 Erneut versuchen
							</button>
						</div>
					`;
				}
			} catch (error) {
				console.error('Fehler beim Laden der Profile:', error);
				// Dies ist der Block für einen echten Netzwerkfehler.
				// Er zeigt auch die gleiche Anzeige, wie du es wolltest.
				cardStack.innerHTML = `
					<div class="text-center p-12 flex flex-col items-center justify-center h-full">
						<div class="text-6xl mb-4">😞</div>
						<h3 class="text-xl font-bold text-gray-700 mb-2">Laden fehlgeschlagen</h3>
						<p class="text-gray-500 mb-6">Ein Verbindungsfehler ist aufgetreten.</p>
						<button onclick="loadSwipeCards()" class="bg-blue-500 text-white px-6 py-3 rounded-full hover:bg-blue-600">
							🔄 Erneut versuchen
						</button>
					</div>
				`;
			}
		}

		function createSwipeCard(profile, stackIndex) {
			const cardStack = document.getElementById('cardStack');
			
			const card = document.createElement('div');
			card.className = 'swipe-card';
			card.style.zIndex = 10 - stackIndex;
			card.style.transform = `scale(${1 - stackIndex * 0.03}) translateY(${stackIndex * 4}px)`;
			card.dataset.userId = profile.user_id;
			card.dataset.stackIndex = stackIndex;
			
			const imageUrl = profile.profile_image;

			// Calculate distance if both profiles have coordinates
			let distanceText = '';
			if (currentProfile && currentProfile.latitude && currentProfile.longitude && 
				profile.latitude && profile.longitude) {
				const distance = calculateDistance(
					currentProfile.latitude, currentProfile.longitude,
					profile.latitude, profile.longitude
				);
				distanceText = `${distance} km entfernt`;
			} else {
				// Fallback: Generate random distance for demo purposes
				const randomDistance = Math.floor(Math.random() * 50) + 1;
				distanceText = `${randomDistance} km entfernt`;
			}

			// Format age display
			const ageDisplay = profile.age ? `, ${profile.age}` : '';
			
			// Interessen formatieren (nur die ersten 4 anzeigen)
			const interests = (profile.interests || []).slice(0, 4).map(interest => 
				`<span class="preference-icon">${emojiMap[interest] || hobbiesMap[interest] || '❓'}</span>`
			).join('');
			
			card.innerHTML = `
				<img src="${imageUrl}" 
					 alt="${profile.profile_name}" 
					 class="card-image"
				>
				<div class="card-content">
					<div class="card-header">
						<div class="card-name-age">
							<h3 class="card-name">${profile.profile_name}${ageDisplay}</h3>
						</div>
						<div class="card-distance">${distanceText}</div>
					</div>
					<p class="card-description">${profile.description || 'Keine Beschreibung verfügbar'}</p>
					<div class="card-preferences">
						${interests}
						${(profile.interests || []).length > 4 ? '<span class="more-interests">+' + ((profile.interests || []).length - 4) + '</span>' : ''}
					</div>
				</div>
			`;
			
			// Profil-Daten an Card binden
			card.__profile = profile;
			
			// Event Listeners nur für die oberste Karte
			if (stackIndex === 0) {
				setupSwipeGestures(card);
				
				// Klick für Profil-Details (nur auf Bild)
				const cardImage = card.querySelector('.card-image');
				cardImage.addEventListener('click', (e) => {
					e.stopPropagation();
					showProfileDetails(profile);
				});
			}
			
			cardStack.appendChild(card);
		}

		
		// Neue Funktion für Profil-Details
		function showProfileDetails(profile) {
		    const profileName = profile.profile_name || profile.name || "Unbekannt";
		    const profileAge = profile.age ? `, ${profile.age}` : "";
		    const profileDescription = profile.description || "Keine Beschreibung verfügbar";
		    const prefs = profile.interests || profile.preferences || [];
		    let profileImage = profile.profile_image || profile.image;
		
		    // ✅ Entfernung berechnen (falls Koordinaten verfügbar)
		    let distanceText = "";
		    if (profile.latitude && profile.longitude && currentUser?.latitude && currentUser?.longitude) {
		        const dist = calculateDistance(
		            currentUser.latitude, currentUser.longitude,
		            profile.latitude, profile.longitude
		        );
		        distanceText = `<p class="text-gray-500 text-sm mb-2">📍 ${dist} km entfernt</p>`;
		    }
		
		    // ✅ Prompts & Antworten
		    let promptsHtml = "";
		    if (profile.prompt1 && profile.answer1) {
		        promptsHtml += `
		            <div class="mb-4">
		                <h4 class="text-md font-semibold text-gray-700 mb-1">${profile.prompt1}</h4>
		                <p class="text-gray-600">${profile.answer1}</p>
		            </div>`;
		    }
		    if (profile.prompt2 && profile.answer2) {
		        promptsHtml += `
		            <div class="mb-4">
		                <h4 class="text-md font-semibold text-gray-700 mb-1">${profile.prompt2}</h4>
		                <p class="text-gray-600">${profile.answer2}</p>
		            </div>`;
		    }
		
		    // ✅ Interessen rendern
		    const preferencesHtml = prefs.map(pref => {
		        const emoji = emojiMap[pref] || hobbiesMap[pref] || '❓';
		        return `<span class="inline-block m-1 px-3 py-1 bg-gray-100 rounded-full text-sm font-medium">${emoji} ${pref}</span>`;
		    }).join('');
		
		    // ✅ Gesamtes Modal
		    const detailsHtml = `
		        <div class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4" 
		             onclick="closeProfileModal()">
		            <div class="bg-white rounded-2xl max-w-md w-full max-h-90vh overflow-y-auto" 
		                 onclick="event.stopPropagation()">
		                <div class="relative">
		                    <img src="${profileImage}" 
		                         alt="${profileName}" 
		                         class="w-full h-64 object-cover rounded-t-2xl"
		                         onerror="this.src='${profileImage}'">
		                    <button onclick="closeProfileModal()" 
		                            class="absolute top-4 right-4 w-8 h-8 bg-black bg-opacity-50 text-white rounded-full flex items-center justify-center hover:bg-opacity-70">
		                        ✕
		                    </button>
		                </div>
		                <div class="p-6">
		                    <h2 class="text-2xl font-bold text-gray-800 mb-1">${profileName}${profileAge}</h2>
		                    ${distanceText}
		                    <p class="text-gray-600 mb-4 leading-relaxed">${profileDescription}</p>
		
		                    ${prefs.length > 0 ? `
		                        <div class="mb-6">
		                            <h4 class="text-lg font-semibold text-gray-700 mb-2">Interessen</h4>
		                            <div class="flex flex-wrap">
		                                ${preferencesHtml}
		                            </div>
		                        </div>
		                    ` : ''}
		
		                    ${promptsHtml}
		
		                    <div class="flex space-x-3">
		                        <button onclick="swipeCard('left'); closeProfileModal();" 
		                                class="flex-1 bg-gradient-to-r from-red-500 to-red-600 text-white py-3 px-6 rounded-full hover:from-red-600 hover:to-red-700 transition-colors font-semibold">
		                            ❌ Nein
		                        </button>
		                        <button onclick="swipeCard('right'); closeProfileModal();" 
		                                class="flex-1 bg-gradient-to-r from-green-500 to-green-600 text-white py-3 px-6 rounded-full hover:from-green-600 hover:to-green-700 transition-colors font-semibold">
		                            💖 Ja
		                        </button>
		                    </div>
		                </div>
		            </div>
		        </div>
		    `;
		    
		    // Entferne vorherige Modals
		    const existingModal = document.querySelector('[data-profile-modal]');
		    if (existingModal) {
		        existingModal.remove();
		    }
		    
		    const modalDiv = document.createElement('div');
		    modalDiv.setAttribute('data-profile-modal', 'true');
		    modalDiv.innerHTML = detailsHtml;
		    document.body.appendChild(modalDiv);
		}
		
		// Event Listeners für Keyboard Shortcuts (aktualisiert)
		document.addEventListener('keydown', (e) => {
		    // Escape für Modals
		    if (e.key === 'Escape') {
		        closeLogin();
		        closeProfileModal();
		        closeProfilePopup();
		        if (sidebarOpen) closeSidebar();
		    }
		    
		    // Swipe shortcuts nur wenn Swipe-Container sichtbar
		    const swipeContainer = document.getElementById('swipeContainer');
		    if (swipeContainer && swipeContainer.style.display === 'block') {
		        if (e.key === 'ArrowLeft') {
		            e.preventDefault();
		            swipeCard('left');
		        }
		        if (e.key === 'ArrowRight') {
		            e.preventDefault();
		            swipeCard('right');
		        }
		            
		        }
		    
		});
		
		function closeProfileModal() {
		    const modal = document.querySelector('[data-profile-modal]');
		    if (modal) {
		        modal.remove();
		    }
		}

		function shuffle(array) {
			return array.sort(() => Math.random() - 0.5);
		}

		     // Swipe Gesten Setup
		function setupSwipeGestures(card) {
		    let startX = 0, startY = 0;
		    let currentX = 0, currentY = 0;
		    let isDragging = false;
		    
		    // Mouse Events
		    card.addEventListener('mousedown', handleStart);
		    document.addEventListener('mousemove', handleMove);
		    document.addEventListener('mouseup', handleEnd);
		    
		    // Touch Events
		    card.addEventListener('touchstart', handleStart, { passive: true });
		    document.addEventListener('touchmove', handleMove, { passive: false });
		    document.addEventListener('touchend', handleEnd);
		            function startDrag(e) {
		                if (card !== document.querySelector('.swipe-card:last-child')) return;
		                
		                cardBeingDragged = true;
		                card.classList.add('dragging');
		                
		                startX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
		                
		                document.addEventListener('mousemove', drag);
		                document.addEventListener('touchmove', drag);
		                document.addEventListener('mouseup', endDrag);
		                document.addEventListener('touchend', endDrag);
		            }

		    function handleStart(e) {
		        if (isSwipeInProgress) return;
		        
		        const clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
		        const clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
		        
		        startX = clientX;
		        startY = clientY;
		        isDragging = true;
		        
		        card.style.transition = '';
		        card.style.cursor = 'grabbing';
		    }
		    
		    function handleMove(e) {
		        if (!isDragging || isSwipeInProgress) return;
		        
		        e.preventDefault();
		        
		        const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
		        const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
		        
		        currentX = clientX - startX;
		        currentY = clientY - startY;
		        
		        // Rotation und Opacity basierend auf X-Position
		        const rotation = currentX * 0.1;
		        const opacity = Math.max(0.3, 1 - Math.abs(currentX) / 300);
		        
		        card.style.transform = `translateX(${currentX}px) translateY(${currentY}px) rotate(${rotation}deg)`;
		        card.style.opacity = opacity;
		        
		        // Visuelle Hinweise
		        if (Math.abs(currentX) > 50) {
		            card.style.boxShadow = currentX > 0 ? 
		                '0 0 20px rgba(76, 175, 80, 0.5)' : 
		                '0 0 20px rgba(255, 107, 107, 0.5)';
		        }
		    }
		    
		    function handleEnd(e) {
		        if (!isDragging) return;
		        
		        isDragging = false;
		        card.style.cursor = 'grab';
		        card.style.boxShadow = '';
		        
		        // Entscheidung basierend auf Swipe-Distanz
		        if (Math.abs(currentX) > 100) {
		            const direction = currentX > 0 ? 'right' : 'left';
		            completeSwipe(direction);
		        } else {
		            // Zurück zur ursprünglichen Position
		            card.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
		            card.style.transform = '';
		            card.style.opacity = '';
		        }
		        
		        currentX = 0;
		        currentY = 0;
		    }
		}	

		function drag(e) {
			if (!cardBeingDragged) return;
			
			e.preventDefault();
			currentX = (e.type === 'mousemove' ? e.clientX : e.touches[0].clientX) - startX;
			
			const rotation = currentX * 0.1;
			const opacity = 1 - Math.abs(currentX) / 300;
			
			card.style.transform = `translateX(${currentX}px) rotate(${rotation}deg)`;
			card.style.opacity = opacity;
		}

		function endDrag() {
			if (!cardBeingDragged) return;
			
			cardBeingDragged = false;
			card.classList.remove('dragging');
			
			document.removeEventListener('mousemove', drag);
			document.removeEventListener('touchmove', drag);
			document.removeEventListener('mouseup', endDrag);
			document.removeEventListener('touchend', endDrag);

			if (Math.abs(currentX) > 100) {
				const direction = currentX > 0 ? 'right' : 'left';
				completeSwipe(card, profile, direction);
			} else {
				// Snap back
				card.style.transform = '';
				card.style.opacity = '';
			}
			
			currentX = 0;
		}

		// Funktion zum Anzeigen des nächsten Profils
		function showNextCard() {
			if (currentIndex < currentProfiles.length) {
				currentSwipeUser = currentProfiles[currentIndex];
				const swipeContainer = document.getElementById('swipeContainer');
				
				// Lösche alte Karten, um nur eine anzuzeigen
				swipeContainer.innerHTML = '';
				
				// Erstelle eine neue Karte
				const card = document.createElement('div');
				card.className = 'swipe-card bg-white rounded-lg shadow-lg p-6 w-full max-w-sm transition-all duration-300 transform';
				card.innerHTML = `
					<img src="${currentSwipeUser.profile_image}" alt="Profilbild von ${currentSwipeUser.name}" class="rounded-lg mb-4 w-full h-auto">
					<h3 class="text-xl font-bold">${currentSwipeUser.name}</h3>
					<p class="text-gray-600 mt-2">${currentSwipeUser.description}</p>
				`;
				swipeContainer.appendChild(card);
				
				currentIndex++;
			} else {
				// Keine Profile mehr zum Anzeigen, zeige eine entsprechende Nachricht
				const swipeContainer = document.getElementById('swipeContainer');
				swipeContainer.innerHTML = `
					<div class="text-center p-8 text-gray-500">
						<p>Das war's für heute! Schau später wieder vorbei, vielleicht gibt es neue Leute in deiner Nähe.</p>
					</div>
				`;
			}
		}

		// Swipe über Buttons
		function swipeCard(direction) {
		    if (isSwipeInProgress) return;
		    
		    const activeCard = document.querySelector('.swipe-card[data-stack-index="0"]');
		    if (!activeCard) {
		        console.log('Keine aktive Karte gefunden');
		        return;
		    }
		    
		    completeSwipe(direction);
		}


		function nextProfileFromDeck() {
		  // einfache Nachlade-Strategie: nimm das nächste Profil, wenn vorhanden
		  const next = currentProfiles[currentCardIndex + 2];
		  currentCardIndex++;
		  return next;
		}
		
		async function handleSwipe(profile, isLike) {
		    if (!isLike) return; // Nur bei Likes weiter
		    
		    try {
		        const likerId = currentUser.uid;
		        // Prüfe ob es ein DB-Profil oder Sample-Profil ist
		        const likedId = profile.user_id || profile.id; // DB hat user_id, Samples haben id
		        
		        if (!likedId || typeof likedId !== 'number') {
		            // Sample-Profile -> lokale Match-Simulation
		            showNotification(`💖 Match mit ${profile.name || profile.profile_name}!`, 'success');
		            return;
		        }
		        
		        // Echtes DB-Profil -> API-Aufruf
		        const response = await fetch('/.netlify/functions/create_match', {
		            method: 'POST',
		            headers: { 'Content-Type': 'application/json' },
		            body: JSON.stringify({ 
		                likerId: likerId,
		                likedId: likedId 
		            })
		        });
		
		        const result = await response.json();
		        		        
		    } catch (error) {
		        console.error('Fehler beim Erstellen des Matches:', error);
		        // Zeige trotzdem positive Nachricht
		        showNotification(`💖 Match mit ${profile.profile_name || profile.name}!`, 'success');
		    }
		}

						
		// Swipe abschließen
		async function completeSwipe(direction) {
			if (isSwipeInProgress) return;
			
			isSwipeInProgress = true;
			
			const activeCard = document.querySelector('.swipe-card[data-stack-index="0"]');
			if (!activeCard || !activeCard.__profile) {
				isSwipeInProgress = false;
				return;
			}
			
			const profile = activeCard.__profile;
			const isLike = direction === 'right';
			
			// 🔥 Speichern für SwipeBack
			lastSwipedProfile = profile;			
					
			// Animation
			activeCard.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
			const moveX = direction === 'right' ? 400 : -400;
			const rotation = direction === 'right' ? 30 : -30;
			
			activeCard.style.transform = `translateX(${moveX}px) rotate(${rotation}deg)`;
			activeCard.style.opacity = '0';
			
			    
			// 🔥 Swipe in DB speichern (nur echte Profile)
			if (!profile.isAI) {
				try {
					await fetch('/.netlify/functions/record_swipe', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							userId: currentUser.uid,
							swipedUserId: profile.user_id,
							direction: direction
						})
					});
				} catch (error) {
					console.error('Fehler beim Aufzeichnen des Swipes:', error);
				}
			}
			
			// Like/Dislike verarbeiten
			if (isLike) {
				await handleLike(profile);
			}
			
			// Karte nach Animation entfernen
			setTimeout(() => {
				activeCard.remove();
				currentIndex++;
				
				// Verbleibende Karten neu positionieren
				updateCardStack();
				
				// Neue Karte laden falls verfügbar
				if (currentIndex + 2 < currentProfiles.length) {
					const newProfile = currentProfiles[currentIndex + 2];
					createSwipeCard(newProfile, 2);
				}
				
				// ✅ FIX: Check if no more cards and call the unified function
				if (currentIndex >= currentProfiles.length) {
					setTimeout(() => {
						showNoMoreProfilesInCardStack();
					}, 500);
				}
				
				isSwipeInProgress = false;
			}, 300);
		}

		function updateCardStack() {
			const cards = document.querySelectorAll('.swipe-card');
			cards.forEach((card, index) => {
				card.dataset.stackIndex = index;
				card.style.zIndex = 10 - index;
				card.style.transform = `scale(${1 - index * 0.03}) translateY(${index * 4}px)`;
				
				// Event Listeners nur für die neue oberste Karte
				if (index === 0 && !card.hasAttribute('data-gestures-setup')) {
					setupSwipeGestures(card);
					card.setAttribute('data-gestures-setup', 'true');
					
					// Klick für Profil-Details - auf der gesamten Karte
					card.addEventListener('click', (e) => {
						e.stopPropagation();
						// Verhindert das Öffnen des Popups, wenn der Swipe-Aktions-Bereich geklickt wird
						if (e.target.closest('.swipe-actions')) {
							return;
						}
						showProfileDetails(card.__profile);
					});
				}
			});
		}

		async function handleLike(profile) {
			try {
				console.log('💖 Like für:', profile.profile_name || profile.name);

				const isAIMatch = profile.isAI || typeof profile.user_id === 'string';

				// --- Prüfen, ob Match lokal schon existiert ---
				let localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
				if (
					localMatches.some(m => (isAIMatch ? m.ai_profile_id === profile.id : m.matched_user_id === profile.user_id))
				) {
					console.log('ℹ️ Match existiert bereits lokal, kein Request nötig');
					return;
				}

				if (isAIMatch) {
					if (!profile.id) throw new Error('AI Profile ID fehlt!');

					await fetch('/.netlify/functions/ensure_ai_dummy', { method: 'POST' });

					const response = await fetch('/.netlify/functions/create_match', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							likerId: parseInt(currentUser.uid),
							likedId: 0,
							aiProfileId: profile.id
						})
					});

					const result = await response.json();
					if (!result.success) throw new Error(result.error || 'Failed to create AI match');

					const realMatchId = result.matchId;

					const aiMatch = {
						id: realMatchId,
						match_id: realMatchId,
						matched_user_id: 0,
						ai_profile_id: profile.id,
						profile_name: profile.profile_name || profile.name,
						profile_image: profile.profile_image || profile.image,
						description: profile.description,
						interests: profile.interests || profile.preferences,
						age: profile.age,
						matched_at: Date.now(),
						is_ai_match: true,
						isAI: true
					};

					addToLocalMatches(aiMatch);

					showNotification('🎉 Es ist ein Match! 💕', 'success');
					showMatchAnimation(profile);
					openMatchChat(realMatchId, 0, aiMatch.profile_name, aiMatch.profile_image);
					return;
				}

				// --- normale User-Likes ---
				const response = await fetch('/.netlify/functions/create_match', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						likerId: parseInt(currentUser.uid),
						likedId: parseInt(profile.user_id)
					})
				});

				const result = await response.json();
				if (result.success && result.newMatch) {
					const matchId = result.matchId;
					addToLocalMatches({
						id: matchId,
						match_id: matchId,
						matched_user_id: profile.user_id,
						profile_name: profile.profile_name || profile.name,
						profile_image: profile.profile_image || profile.image,
						matched_at: Date.now(),
						is_ai_match: false
					});
					showNotification('🎉 Es ist ein Match!', 'success');
					openMatchChat(matchId, profile.user_id, profile.profile_name || profile.name, profile.profile_image || profile.image);
				}

			} catch (error) {
				console.error('Fehler beim Like:', error);
				showNotification('❌ Fehler beim Match erstellen', 'error');
			}
		}

		function addToLocalMatches(match) {
			let localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
			const exists = localMatches.some(m => m.match_id == match.match_id);
			if (!exists) {
				localMatches.push(match);
				localStorage.setItem('userMatches', JSON.stringify(localMatches));
				console.log('✅ Match added to localMatches', match.match_id);
			} else {
				console.log('ℹ️ Match already exists (local)', match.match_id);
			}
		}


		function addToLocalMatches(match) {
		  let localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
		  const id = match.match_id || match.id;
		  const exists = localMatches.some(m => m.match_id == id || m.id == id);
		  if (!exists) {
			const store = Object.assign({}, match, { match_id: id, id: id });
			localMatches.push(store);
			localStorage.setItem('userMatches', JSON.stringify(localMatches));
			console.log('✅ Match added to localMatches', id);
		  } else {
			console.log('ℹ️ Match already exists (local)', id);
		  }
		}


		// ✅ UPDATED: Replace your existing showNoMoreCards function
		function showNoMoreCards() {
			// Just call the unified function
			showNoMoreProfilesInCardStack();
		}

				
		async function reloadProfiles() {
			const cardStack = document.getElementById('cardStack');
			const swipeActions = document.querySelector('.swipe-actions');
			
			cardStack.style.cssText = `
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 100px;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				z-index: 1;
			`;
			
			cardStack.innerHTML = `
			  <div class="infinity-loader">
				<svg width="200" height="100" viewBox="0 0 200 100" xmlns="http://www.w3.org/2000/svg">
				  <!-- Infinity-Pfad -->
				  <path d="M 50,50
						   C 50,20 100,20 100,50
						   C 100,80 150,80 150,50
						   C 150,20 100,20 100,50
						   C 100,80 50,80 50,50Z"
						fill="none"
						stroke="url(#chromeStroke)"
						stroke-width="6"
						stroke-linecap="round"/>
				  
				  <!-- Shine Sweep -->
				  <path d="M 50,50
						   C 50,20 100,20 100,50
						   C 100,80 150,80 150,50
						   C 150,20 100,20 100,50
						   C 100,80 50,80 50,50Z"
						fill="none"
						stroke="url(#shineStroke)"
						stroke-width="10"
						stroke-linecap="round"
						stroke-dasharray="100 300"
						stroke-dashoffset="0"
						opacity="0.6">
					<animate attributeName="stroke-dashoffset" values="0;-400" dur="5s" repeatCount="indefinite"/>
				  </path>
				  
				  <defs>
					<!-- Chrome Basis-Stroke -->
					<linearGradient id="chromeStroke" x1="0%" y1="0%" x2="100%" y2="100%">
					  <stop offset="0%" stop-color="#f8f9fa"/>
					  <stop offset="25%" stop-color="#dee2e6"/>
					  <stop offset="50%" stop-color="#adb5bd"/>
					  <stop offset="75%" stop-color="#6c757d"/>
					  <stop offset="100%" stop-color="#212529"/>
					</linearGradient>
					
					<!-- Shine-Effekt -->
					<linearGradient id="shineStroke" x1="0%" y1="0%" x2="100%" y2="0%">
					  <stop offset="0%" stop-color="#ffffff" stop-opacity="0"/>
					  <stop offset="50%" stop-color="#ffffff" stop-opacity="1"/>
					  <stop offset="100%" stop-color="#ffffff" stop-opacity="0"/>
					</linearGradient>
				  </defs>
				</svg>
			  </div>
			  
			  <style>
				.infinity-loader {
				  display: flex;
				  justify-content: center;
				  align-items: center;
				  animation: rotateLuxury 12s cubic-bezier(0.65, 0, 0.35, 1) infinite;
				  filter: drop-shadow(0 8px 16px rgba(0,0,0,0.4)) drop-shadow(0 2px 4px rgba(0,0,0,0.2));
				}

				@keyframes rotateLuxury {
				  0% { transform: rotate(0deg); }
				  50% { transform: rotate(180deg); }
				  100% { transform: rotate(360deg); }
				}
			  </style>
			`;


			
			try {
				currentIndex = 0;
				currentProfiles = [];
				
				const loadPromise = loadProfiles();
				const timeoutPromise = new Promise((_, reject) => 
					setTimeout(() => reject(new Error('timeout')), 5000)
				);
				
				await Promise.race([loadPromise, timeoutPromise]);
				
				if (!currentProfiles || currentProfiles.length === 0) {
					setTimeout(() => {
						showNoMoreCards();
					}, 1000);
				}
				
			} catch (error) {
				console.error('Fehler beim Neuladen:', error);
				setTimeout(() => {
					showNoMoreCards();
				}, 1000);
			}
		}
		// Match Animation
		function showMatchAnimation(profile) {
		    const overlay = document.createElement('div');
		    overlay.style.cssText = `
		        position: fixed;
		        top: 0;
		        left: 0;
		        right: 0;
		        bottom: 0;
		        background: linear-gradient(135deg, #ff6b6b, #ee5a52);
		        display: flex;
		        align-items: center;
		        justify-content: center;
		        z-index: 3000;
		        opacity: 0;
		        transition: opacity 0.3s ease;
		    `;
		    
		    overlay.innerHTML = `
		        <div style="text-align: center; color: white;">
		            <div style="font-size: 6rem; margin-bottom: 20px; animation: pulse 1s infinite;">💕</div>
		            <h2 style="font-size: 2.5rem; margin-bottom: 10px;">It's a Match!</h2>
		            <p style="font-size: 1.2rem; opacity: 0.9;">Du und ${profile.profile_name} habt euch geliked!</p>
		            <button onclick="this.parentElement.parentElement.remove()" 
		                    style="margin-top: 30px; padding: 15px 30px; background: white; color: #333; border: none; border-radius: 25px; font-size: 1.1rem; cursor: pointer;">
		                Weiter swipen
		            </button>
		        </div>
		    `;
		    
		    document.body.appendChild(overlay);
		    
		    // Animation starten
		    setTimeout(() => overlay.style.opacity = '1', 10);
		    
		    // Auto-remove nach 4 Sekunden
		    setTimeout(() => {
		        if (overlay.parentElement) {
		            overlay.remove();
		        }
		    }, 4000);
		}		
		
		// Function to check user status and update UI
		async function checkUserPlusStatus() {
			if (!currentUser || !currentUser.uid) return;
			
			try {
				const response = await fetch('/.netlify/functions/get_user_status', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});
				
				const result = await response.json();
				if (result.success) {
					isUserPlus = result.isUserPlus;
					isAdmin = result.isAdmin;
					updatePremiumButtons();
				}
			} catch (error) {
				console.error('Fehler beim Überprüfen des UserPlus-Status:', error);
			}
		}

		function updateFloatingButtons() {
			const profileBtn = document.getElementById('profileButton');
			const chatBtn = document.getElementById('chatButton');
			
			if (!profileBtn || !chatBtn) return;
			
			if (currentUser && currentUser.uid) {
				const swipeContainer = document.getElementById('swipeContainer');
				const isSwipeView = swipeContainer && window.getComputedStyle(swipeContainer).display === 'block';
				
				if (isSwipeView) {
					// Force show with important styles
					profileBtn.classList.remove('hidden');
					chatBtn.classList.remove('hidden');
					
					profileBtn.style.cssText = `
						position: fixed !important;
						bottom: 2rem !important;
						left: 2rem !important;
						width: 4rem !important;
						height: 4rem !important;
						border-radius: 50% !important;
						background-color: #ff5e5e !important;
						color: white !important;
						display: flex !important;
						align-items: center !important;
						justify-content: center !important;
						box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
						cursor: pointer !important;
						z-index: 5 !important;
						border: none !important;
						visibility: visible !important;
						opacity: 1 !important;
					`;
					
					chatBtn.style.cssText = `
						position: fixed !important;
						bottom: 2rem !important;
						right: 2rem !important;
						width: 4rem !important;
						height: 4rem !important;
						border-radius: 50% !important;
						background-color: #007bff !important;
						color: white !important;
						display: flex !important;
						align-items: center !important;
						justify-content: center !important;
						box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
						cursor: pointer !important;
						z-index: 2000 !important;
						border: none !important;
						visibility: visible !important;
						opacity: 1 !important;
					`;
				} else {
					profileBtn.classList.add('hidden');
					chatBtn.classList.add('hidden');
				}
			} else {
				profileBtn.classList.add('hidden');
				chatBtn.classList.add('hidden');
			}
		}
				
		function updateSwipeActionButtons() {
			const existingButtons = document.querySelector('.floating-buttons');
			if (existingButtons) {
				existingButtons.remove();
			}

			const swipeContainer = document.getElementById('swipeContainer');
			const currentScreen = swipeContainer && swipeContainer.style.display === 'block';
			
			if (!currentScreen) return;

			const buttonsHtml = `
				<div class="floating-buttons fixed bottom-1 left-1/2 transform -translate-x-1/2 flex items-center space-x-4 z-50">
					<!-- Swipe Back Button (UserPlus only) -->
					<button id="swipeBackBtn" 
							onclick="swipeBack()" 
							class="premium-btn ${!isUserPlus && !isAdmin ? 'premium-btn-locked' : 'premium-btn-active'} 
								   w-12 h-12 rounded-full flex items-center justify-center transition-all duration-300 shadow-lg"
							${!isUserPlus && !isAdmin ? 'disabled' : ''}>
						<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
							<path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
						</svg>
						${!isUserPlus && !isAdmin ? '<span class="premium-lock">🔒</span>' : ''}
					</button>
					
					<!-- Dislike Button -->
					<button onclick="swipeCard('left')" 
							class="bg-white text-red-500 border-2 border-red-200 w-16 h-16 rounded-full flex items-center justify-center hover:bg-red-50 transition-all duration-300 shadow-lg">
						<svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24">
							<path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
						</svg>
					</button>
					
					<!-- Like Button -->
					<button onclick="swipeCard('right')" 
							class="bg-gradient-to-r from-pink-500 to-red-500 text-white w-16 h-16 rounded-full flex items-center justify-center hover:from-pink-600 hover:to-red-600 transition-all duration-300 shadow-lg">
						<svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24">
							<path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
						</svg>
					</button>
					
					<!-- InstaMatch Button (UserPlus only) -->
					<button id="instaMatchBtn" 
							onclick="instaMatch()" 
							class="premium-btn ${!isUserPlus && !isAdmin ? 'premium-btn-locked' : 'premium-btn-active'} 
								   w-12 h-12 rounded-full flex items-center justify-center transition-all duration-300 shadow-lg"
							${!isUserPlus && !isAdmin ? 'disabled' : ''}>
						<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
							<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
						</svg>
						${!isUserPlus && !isAdmin ? '<span class="premium-lock">🔒</span>' : ''}
					</button>
				</div>
			`;

			document.body.insertAdjacentHTML('beforeend', buttonsHtml);
		}	

		// Swipe Back functionality
		async function swipeBack() {
			if (!isUserPlus && !isAdmin) {
				showUserPlusPurchase();
				return;
			}
			
			if (!currentUser || !currentUser.uid) {
				showNotification('❌ Bitte melden Sie sich an', 'error');
				return;
			}
			
			try {
				const response = await fetch('/.netlify/functions/swipe_back', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});
				
				const result = await response.json();
				
				if (result.success && result.profile) {
					// Add the profile back to the beginning
					currentProfiles.unshift(result.profile);
					currentIndex = Math.max(0, currentIndex - 1);
					
					// Re-render cards
					renderSwipeCards();
					
					showNotification('✅ Letzter Swipe rückgängig gemacht!', 'success');
				} else {
					showNotification(result.message || '❌ Kein vorheriger Swipe gefunden', 'info');
				}
			} catch (error) {
				console.error('Fehler beim Swipe Back:', error);
				showNotification('❌ Fehler beim Swipe Back', 'error');
			}
		}

		// InstaMatch functionality
		async function instaMatch() {
			if (!isUserPlus && !isAdmin) {
				showUserPlusPurchase();
				return;
			}
			
			const activeCard = document.querySelector('.swipe-card[data-stack-index="0"]');
			if (!activeCard || !activeCard.__profile) {
				showNotification('❌ Kein Profil zum Matchen verfügbar', 'error');
				return;
			}
			
			const profile = activeCard.__profile;
			
			if (profile.isAI) {
				// Handle AI InstaMatch
				await handleLike(profile);
				completeSwipe('right');
			} else {
				// Handle real user InstaMatch
				try {
					const response = await fetch('/.netlify/functions/create_match', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							likerId: parseInt(currentUser.uid),
							likedId: parseInt(profile.user_id),
							isInstaMatch: true
						})
					});
					
					const result = await response.json();
					
					if (result.success) {
						showNotification('⚡ InstaMatch erfolgreich!', 'success');
						showMatchAnimation(profile);
						completeSwipe('right');
					} else {
						showNotification('❌ InstaMatch fehlgeschlagen', 'error');
					}
				} catch (error) {
					console.error('Fehler beim InstaMatch:', error);
					showNotification('❌ Fehler beim InstaMatch', 'error');
				}
			}
		}
		// Initialize UserPlus features when user logs in
		async function initializeUserPlusFeatures() {
			await checkUserPlusStatus();
			addUserPlusToSidebar(isUserPlus, isAdmin);
			updateFloatingButtons();
			updateSwipeActionButtons();
		}				
		
		// Show UserPlus purchase modal
		function showUserPlusPurchase() {
			const modalHtml = `
				<div class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4" onclick="closeUserPlusPurchase()">
					<div class="bg-white rounded-2xl max-w-md w-full p-6" onclick="event.stopPropagation()">
						<div class="text-center">
							<div class="text-6xl mb-4">⭐</div>
							<h2 class="text-2xl font-bold mb-4 text-gray-800">
								UserPlus für €4,99
								<span style="color: #6b7280; font-size: 0.6em; vertical-align: super;">*</span>
							</h2>
							<div class="text-left mb-6 space-y-3">
								<div class="flex items-center">
									<div class="w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center mr-3">
										<svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 24 24">
											<path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
										</svg>
									</div>
									<span class="text-gray-700">Swipe Back - Letzten Swipe rückgängig machen</span>
								</div>
								<div class="flex items-center">
									<div class="w-6 h-6 bg-yellow-500 rounded-full flex items-center justify-center mr-3">
										<svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 24 24">
											<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
										</svg>
									</div>
									<span class="text-gray-700">InstaMatch - Sofortiges Match ohne gegenseitigen Like</span>
									<span style="color: #6b7280; font-size: 0.6em; vertical-align: super;">**</span>
								</div>
							</div>
							
							<div id="paypal-button-container" class="my-4"></div>
							
							<button onclick="closeUserPlusPurchase()" 
									class="w-full bg-gray-200 text-gray-700 py-2 px-6 rounded-full hover:bg-gray-300 transition-colors">
								Später
							</button>
							<p style="text-align: center; color: #6b7280; font-size: 0.8em; margin-top: 5px;">
								*UserPlus für 4,99€ ist nach dem Kauf eine Woche gültig und
							<p style="text-align: center; color: #6b7280; font-size: 0.8em; margin-top: -5px; margin-right: 165px">
								wird nicht automatisch erneuert
							<p style="text-align: center; color: #6b7280; font-size: 0.8em; margin-top: 1px; margin-right: 205px">
								**Verfügbar einmal Pro Tag
							</p>
						</div>
					</div>
				</div>
			`;
			
			const existingModal = document.querySelector('[data-userplus-modal]');
			if (existingModal) {
				existingModal.remove();
			}
			
			const modalDiv = document.createElement('div');
			modalDiv.setAttribute('data-userplus-modal', 'true');
			modalDiv.innerHTML = modalHtml;
			document.body.appendChild(modalDiv);
			
			purchaseUserPlus();

		}

		function closeUserPlusPurchase() {
			const modal = document.querySelector('[data-userplus-modal]');
			if (modal) {
				modal.remove();
			}
		}

		// Purchase UserPlus via PayPal Sandbox
		async function purchaseUserPlus() {
			if (!currentUser || !currentUser.uid) {
				showNotification('❌ Bitte melden Sie sich an', 'error');
				return;
			}

			// Render PayPal-Button in den Container
			paypal.Buttons({
				style: {
					shape: 'pill',
					color: 'blue',
					layout: 'vertical',
					label: 'paypal'
				},
				createOrder: function(data, actions) {
					return actions.order.create({
						purchase_units: [{
							amount: {
								value: '4.99',
								currency_code: 'EUR'
							}
						}]
					});
				},
				onApprove: function(data, actions) {
					return actions.order.capture().then(async function(details) {
						try {
							const orderId = data.orderID;

							// Order-ID an dein Netlify Backend schicken
							const response = await fetch('/.netlify/functions/purchase_userplus', {
								method: 'POST',
								headers: { 'Content-Type': 'application/json' },
								body: JSON.stringify({
									userId: currentUser.uid,
									paymentToken: orderId
								})
							});

							const result = await response.json();

							if (result.success) {
								isUserPlus = true;
								updatePremiumButtons();
								closeUserPlusPurchase();
								showNotification('🎉 UserPlus erfolgreich aktiviert!', 'success');
							} else {
								showNotification('❌ Kauf fehlgeschlagen: ' + result.error, 'error');
							}
						} catch (error) {
							console.error('Fehler beim UserPlus Kauf:', error);
							showNotification('❌ Fehler beim Kauf', 'error');
						}
					});
				},
				onError: function(err) {
					console.error('PayPal-Fehler:', err);
					showNotification('❌ PayPal-Fehler beim Kauf', 'error');
				}
			}).render('#paypal-button-container');
		}


		// Update premium buttons styling
		function updatePremiumButtons() {
			const swipeBackBtn = document.getElementById('swipeBackBtn');
			const instaMatchBtn = document.getElementById('instaMatchBtn');
			
			if (swipeBackBtn) {
				if (isUserPlus || isAdmin) {
					swipeBackBtn.classList.remove('premium-btn-locked');
					swipeBackBtn.classList.add('premium-btn-active');
					swipeBackBtn.disabled = false;
					const lock = swipeBackBtn.querySelector('.premium-lock');
					if (lock) lock.remove();
				} else {
					swipeBackBtn.classList.add('premium-btn-locked');
					swipeBackBtn.classList.remove('premium-btn-active');
					swipeBackBtn.disabled = true;
					if (!swipeBackBtn.querySelector('.premium-lock')) {
						swipeBackBtn.innerHTML += '<span class="premium-lock">🔒</span>';
					}
				}
			}
			
			if (instaMatchBtn) {
				if (isUserPlus || isAdmin) {
					instaMatchBtn.classList.remove('premium-btn-locked');
					instaMatchBtn.classList.add('premium-btn-active');
					instaMatchBtn.disabled = false;
					const lock = instaMatchBtn.querySelector('.premium-lock');
					if (lock) lock.remove();
				} else {
					instaMatchBtn.classList.add('premium-btn-locked');
					instaMatchBtn.classList.remove('premium-btn-active');
					instaMatchBtn.disabled = true;
					if (!instaMatchBtn.querySelector('.premium-lock')) {
						instaMatchBtn.innerHTML += '<span class="premium-lock">🔒</span>';
					}
				}
			}
		}
				

		function updateChatButtonBadge() {
			const chatBtn = document.getElementById('chatButton');
			if (!chatBtn) return;
			
			// Remove existing badge
			const existingBadge = chatBtn.querySelector('.notification-badge');
			if (existingBadge) {
				existingBadge.remove();
			}
			
			if (unreadMessageCount > 0) {
				const badge = document.createElement('div');
				badge.className = 'notification-badge';
				badge.textContent = unreadMessageCount > 99 ? '99+' : unreadMessageCount.toString();
				badge.style.cssText = `
					position: absolute !important;
					top: -8px !important;
					right: -8px !important;
					background-color: #ff4444 !important;
					color: white !important;
					border-radius: 50% !important;
					width: 24px !important;
					height: 24px !important;
					display: flex !important;
					align-items: center !important;
					justify-content: center !important;
					font-size: 12px !important;
					font-weight: bold !important;
					border: 2px solid white !important;
					animation: pulse 2s infinite !important;
					z-index: 2001 !important;
				`;
				chatBtn.appendChild(badge);
				
				// Add pulsing animation CSS if not already present
				if (!document.getElementById('notification-styles')) {
					const style = document.createElement('style');
					style.id = 'notification-styles';
					style.textContent = `
						@keyframes pulse {
							0% { transform: scale(1); }
							50% { transform: scale(1.1); }
							100% { transform: scale(1); }
						}
					`;
					document.head.appendChild(style);
				}
			}
		}

		// Function to check for new messages across all chats
		async function checkForNewMessages() {
			if (!currentUser || !currentUser.uid) return;
			
			let newMessageCount = 0;
			
			try {
				// Check real user matches
				const matchesResponse = await fetch('/.netlify/functions/get_matches', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ userId: currentUser.uid })
				});
				
				if (matchesResponse.ok) {
					const matchesResult = await matchesResponse.json();
					if (matchesResult.success && matchesResult.matches) {
						
						for (const match of matchesResult.matches) {
							const matchId = match.match_id;
							
							// Get messages for this match
							const messagesResponse = await fetch('/.netlify/functions/get_messages', {
								method: 'POST',
								headers: { 'Content-Type': 'application/json' },
								body: JSON.stringify({ match_id: matchId })
							});
							
							if (messagesResponse.ok) {
								const messagesResult = await messagesResponse.json();
								if (messagesResult.success && messagesResult.messages) {
									const messages = messagesResult.messages;
									const lastChecked = lastCheckedMessages[matchId] || 0;
									
									// Count unread messages from partner
									const unreadFromPartner = messages.filter(msg => 
										msg.sender_id !== parseInt(currentUser.uid) && 
										new Date(msg.sent_at).getTime() > lastChecked
									).length;
									
									newMessageCount += unreadFromPartner;
								}
							}
						}
					}
				}
				
				// Check AI matches
				const localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
				const aiMatches = localMatches.filter(m => m.isAI);
				
				for (const aiMatch of aiMatches) {
					const chatId = aiMatch.match_id;
					const aiMessages = JSON.parse(localStorage.getItem(`ai_chat_${chatId}`) || '[]');
					const lastChecked = lastCheckedMessages[chatId] || 0;
					
					// Count unread messages from AI
					const unreadFromAI = aiMessages.filter(msg => 
						msg.sender === 'ai' && 
						new Date(msg.timestamp).getTime() > lastChecked
					).length;
					
					newMessageCount += unreadFromAI;
				}
				
				unreadMessageCount = newMessageCount;
				updateChatButtonBadge();
				
			} catch (error) {
				console.error('Error checking for new messages:', error);
			}
		}
	

        function addMatch(profile) {
            if (!matches.find(m => m.id === profile.id)) {
                matches.push({
                    ...profile,
                    matchedAt: new Date().toISOString(),
                    messages: [
                        {
                            text: `Hey! Schön, dass wir gematcht haben! 😊`,
                            sender: 'system',
                            timestamp: new Date().toISOString()
                        }
                    ]
                });
                localStorage.setItem('matches', JSON.stringify(matches));
            }
        }

        // Chat Functions
        function showMatchesList() {
            document.getElementById('matchesList').style.display = 'block';
            document.getElementById('individualChat').style.display = 'none';
            loadUserMatches(true);
			startMatchesAutoRefresh();
        }

		
		   async function uploadImageToCloudinary(file) {
            console.log('📄 Starting Cloudinary upload for file:', file.name, file.type, file.size);
            
            if (!file.type.startsWith('image/')) {
                throw new Error('Datei ist kein Bild');
            }
            
            if (file.size > 16 * 1024 * 1024) {
                throw new Error('Datei ist zu groß (max 16MB)');
            }
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('upload_preset', 'benches_upload');
            
            try {
                console.log('📤 Uploading to Cloudinary...');
                const response = await fetch('https://api.cloudinary.com/v1_1/dp3t4ctxz/image/upload', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Cloudinary error response:', errorText);
                    
                    let errorMessage = 'Cloudinary-Upload fehlgeschlagen';
                    try {
                        const errorData = JSON.parse(errorText);
                        if (errorData.error && errorData.error.message) {
                            errorMessage += ': ' + errorData.error.message;
                        }
                    } catch (e) {
                        // Fallback wenn Error nicht parsbar ist
                    }
                    
                    throw new Error(errorMessage);
                }
                
                const data = await response.json();
                console.log('✅ Cloudinary upload successful:', data);
                
                await testImageUrl(data.secure_url);
                
                return data.secure_url;
                
            } catch (error) {
                console.error('❌ Upload error:', error);
                throw error;
            }
        }

        function testImageUrl(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    console.log('✅ Uploaded image URL is accessible:', url);
                    resolve();
                };
                img.onerror = () => {
                    console.error('❌ Uploaded image URL is NOT accessible:', url);
                    reject(new Error('Uploaded image is not accessible'));
                };
                img.src = url;
                
                setTimeout(() => {
                    reject(new Error('Image test timeout'));
                }, 10000);
            });
        }
				
		function escapeHtml(text) {
			const map = {
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;',
				'"': '&quot;',
				"'": '&#039;'
			};
			return text.replace(/[&<>"']/g, function(m) { return map[m]; });
		}
		

        function suggestBench() {
            if (!currentChatUser) return;
            
            // Add system message
            if (!currentChatUser.messages) {
                currentChatUser.messages = [];
            }
            
            currentChatUser.messages.push({
                text: "💡 Lass uns eine schöne Bank zum Treffen finden!",
                sender: 'me',
                timestamp: new Date().toISOString()
            });
            
            localStorage.setItem('matches', JSON.stringify(matches));
            
            // Redirect to map with special parameter
            const mapUrl = `index.html?match=${currentChatUser.id}&suggest=true`;
            window.open(mapUrl, '_blank');
            
            showNotification('🗺️ Du wirst zur Bank-Karte weitergeleitet...', 'success');
        }

        // Utility Functions
        function showNotification(message, type) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 5000);
        }

        // Keyboard shortcuts
		document.addEventListener('keydown', e => { 
		    if (e.key === 'Escape') {
		
		        const chat = document.getElementById('chatContainer');
		        const login = document.getElementById('loginContainer');
		        const matches = document.getElementById('matchesContainer');
		
		        // 1️⃣ Chat hat höchste Priorität
		        if (chat && chat.style.display !== 'none') {
		            closeChat();
		            return; // nur Chat schließen
		        }
		
		        // 2️⃣ Sidebar
		        if (sidebarOpen) {
		            closeSidebar();
		            return;
		        }
		
		        // 3️⃣ Login
		        if (login && login.style.display !== 'none') {
		            closeLogin();
		            return;
		        }
		
		        // 4️⃣ Matches Container zuletzt prüfen und schließen
		        if (matches && matches.style.display !== 'none') {
		            matches.style.display = 'none';
		        }
		    }
		
		    // Swipe shortcuts
		    const swipe = document.getElementById('swipeContainer');
		    if (swipe && swipe.style.display === 'block') {
		        if (e.key === 'ArrowLeft') swipeCard('left');
		        if (e.key === 'ArrowRight') swipeCard('right');
		    }
		});
        document.getElementById('profileImage').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const button = document.querySelector('.file-upload-btn');
            const status = document.getElementById('fileStatus');
            const buttonText = document.getElementById('fileButtonText');
            
            if (file) {
                button.classList.add('has-file');
                buttonText.textContent = 'Bild ausgewählt';
                status.textContent = `Ausgewählt: ${file.name}`;
                status.style.color = '#4caf50';
            } else {
                button.classList.remove('has-file');
                buttonText.textContent = 'Bild auswählen';
                status.textContent = 'Kein Bild ausgewählt';
                status.style.color = '#b0b0b0';
            }
        });	
		// Gender-Auswahl Event Listener
		document.querySelectorAll('.gender-btn').forEach(btn => {
			btn.addEventListener('click', function() {
				document.querySelectorAll('.gender-btn').forEach(b => b.classList.remove('selected'));
				this.classList.add('selected');
				selectedGender = this.dataset.gender;
				document.getElementById('genderError').style.display = 'none';
			});
		});

		// Name-Validierung (nur Buchstaben, max 16 Zeichen)
		document.getElementById('profileName').addEventListener('input', function() {
			const value = this.value;
			const cleanValue = value.replace(/[^a-zA-ZäöüÄÖÜß\s]/g, '');
			if (cleanValue !== value) {
				this.value = cleanValue;
			}
			document.getElementById('nameCount').textContent = `${cleanValue.length}/16`;
		});

		// Alter-Validierung (18-99)
		document.getElementById('profileAge').addEventListener('input', function() {
			const age = parseInt(this.value);
			const ageError = document.getElementById('ageError');
			if (age < 18) {
				ageError.textContent = 'Mindestalter ist 18 Jahre';
				ageError.style.display = 'block';
			} else {
				ageError.style.display = 'none';
			}
		});

		// Beschreibung-Validierung (max 2 Sätze, 200 Zeichen)
		document.getElementById('profileDescription').addEventListener('input', function() {
			const value = this.value;
			const sentences = value.split(/[.!?]+/).filter(s => s.trim().length > 0);
			document.getElementById('descriptionCount').textContent = `${value.length}/200`;
			
			const descError = document.getElementById('descriptionError');
			if (sentences.length > 2) {
				descError.textContent = 'Maximal 2 Sätze erlaubt';
				descError.style.display = 'block';
			} else {
				descError.style.display = 'none';
			}
		});

		document.addEventListener('DOMContentLoaded', function() {
		    console.log('🚀 App wird initialisiert...');
		    
		    // Globale Variablen (falls sie hier initialisiert werden)
		    currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
		    matches = JSON.parse(localStorage.getItem('matches') || '[]');
		    currentProfile = JSON.parse(localStorage.getItem('currentProfile') || 'null');
		    
		    // UI-Aktualisierungen
		    updateAuthButtons(currentUser);
		    generateSampleProfiles();
		    renderPreferences();
		    checkAndRenderUI(); // Diese Funktion sollte alle weiteren Schritte auslösen
			renderHobbies();

			const profileForm = document.getElementById('profileForm');
			if (profileForm) {
				profileForm.addEventListener('submit', createProfile);
			}
					
		    // Event-Listener für Buttons
		    const profileBtn = document.getElementById('profileButton');
		    const chatBtn = document.getElementById('chatButton');
		    
		    if (profileBtn) {
		        profileBtn.addEventListener('click', showProfilePopup);
		    }
		    
		    if (chatBtn) {
		        chatBtn.addEventListener('click', showMatches);
		    }
		    
		    console.log('✅ App initialisiert');
		    
		    // Debug Info
		    if (currentUser) {
		        console.log('👤 User angemeldet:', currentUser.email);
		    } else {
		        console.log('👤 Kein User angemeldet');
		    }
		    // Force initial floating button setup
		    if (currentUser) {
		        setTimeout(() => {
		            updateFloatingButtons();
		        }, 500);
		    }
		});	
    </script>
</body>
</html>
