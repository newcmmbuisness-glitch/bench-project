let unreadMessageCount = 0;		
let lastCheckedMessages = {};     
let currentChatUser = null;





    function showChats() {
        if (!currentUser) {
            showLogin();
            showNotification('üîí Sie m√ºssen sich anmelden, um Ihre Matches zu sehen!', 'error');
            return;
        }
        hideAllScreens();
        document.getElementById('chatContainer').style.display = 'block';
        showMatchesList();
    }
		async function loadMessages() {
			const container = document.getElementById('chatMessages');
			const suggestionsContainer = document.getElementById('aiSuggestionsContainer');

			if (!container || !chatState.currentMatchId || !suggestionsContainer) {
				console.error("‚ùå Missing required elements or no active chat");
				return;
			}

			// Check if this is an AI chat - if so, redirect to AI function
			const isAIChat = chatState.isAI;
			if (isAIChat) {
				loadAIMessages();
				return;
			}

			try {
				// Ensure match_id is a number for real chats
				const match_id = parseInt(chatState.currentMatchId);
				if (isNaN(match_id) || match_id <= 0) {
					console.error('‚ùå Invalid match ID for real chat:', chatState.currentMatchId);
					container.innerHTML = `
						<div class="text-center text-red-500 py-8">
							<p>Fehlerhafte Chat-ID</p>
						</div>
					`;
					return;
				}

				const response = await fetch('/.netlify/functions/get_messages', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ match_id })
				});

				const result = await response.json();

				if (response.ok && result.success) {
					const currentMessageCount = result.messages ? result.messages.length : 0;
					const hasNewMessages = currentMessageCount > chatState.lastLoadedMessageCount;
					const isChatEmpty = currentMessageCount === 0;

					if (hasNewMessages || isChatEmpty) {
						container.innerHTML = '';
						
						if (result.messages && result.messages.length > 0) {
							result.messages.forEach(message => {
								const messageClass = message.sender_id === parseInt(currentUser.uid) ? 'sent' : 'received';
								const messageBubble = document.createElement('div');
								messageBubble.classList.add('message', messageClass);
								
								const timestamp = new Date(message.sent_at).toLocaleTimeString('de-DE', { 
									hour: '2-digit', 
									minute: '2-digit' 
								});
								
								messageBubble.innerHTML = `
									<div class="message-bubble">${escapeHtml(message.message_text)}</div>
									<div class="text-xs opacity-50 mt-1">${timestamp}</div>
								`;
								container.appendChild(messageBubble);
							});
						} else {
							container.innerHTML = `
								<div class="text-center text-gray-500 py-8">
									<div class="text-4xl mb-2">üëã</div>
									<p>Schreibt euch eure erste Nachricht!</p>
								</div>
							`;
						}
						
						container.scrollTop = container.scrollHeight;
					}

					// AI suggestions logic for real chats only
					const lastMessage = result.messages[result.messages.length - 1];
					const lastMessageIsFromPartner = lastMessage && lastMessage.sender_id !== parseInt(currentUser.uid);
					
					if ((isChatEmpty && !chatState.aiSuggestionsLoaded) || (hasNewMessages && lastMessageIsFromPartner)) {
						chatState.aiSuggestionsLoaded = true;
						updateSuggestions();
					} else if (!isChatEmpty && !lastMessageIsFromPartner && !hasNewMessages) {
						suggestionsContainer.classList.add('hidden');
					}

					chatState.lastLoadedMessageCount = currentMessageCount;

				} else {
					console.error('‚ùå Error loading messages:', result.error);
					if (container.children.length === 0) {
						container.innerHTML = `
							<div class="text-center text-red-500 py-8">
								<p>Nachrichten konnten nicht geladen werden</p>
								<button onclick="loadMessages()" class="mt-2 px-4 py-2 bg-blue-500 text-white rounded">
									üîÑ Erneut versuchen
								</button>
							</div>
						`;
					}
				}
			} catch (error) {
				console.error('‚ùå Network error loading messages:', error);
				if (container.children.length === 0) {
					container.innerHTML = `
						<div class="text-center text-red-500 py-8">
							<p>Verbindungsfehler</p>
							<button onclick="loadMessages()" class="mt-2 px-4 py-2 bg-blue-500 text-white rounded">
								üîÑ Erneut versuchen
							</button>
						</div>
					`;
				}
			}
		}
		
		async function sendMessage() {
			const messageInput = document.getElementById('messageInput');
			const messageText = messageInput.value.trim();
			
			if (!messageText || !chatState.currentMatchId || !currentUser.uid) {
				
				
				return;
			}
			
			// Check if this is an AI chat
			const isAIChat = chatState.isAI;
			
			// Optimistic update: Show message immediately
			const chatMessages = document.getElementById('chatMessages');
			const messageElement = document.createElement('div');
			messageElement.classList.add('message', 'sent');
			messageElement.innerHTML = `<div class="message-bubble">${escapeHtml(messageText)}</div>`;
			chatMessages.appendChild(messageElement);
			chatMessages.scrollTop = chatMessages.scrollHeight;

			// Clear and disable input
			const originalValue = messageText;
			messageInput.value = '';
			messageInput.disabled = true;

			// Handle real user chat
			console.log("Sending message:", {
			    match_id: parseInt(chatState.currentMatchId),
			    sender_id: parseInt(currentUser.uid),
			    message_text: originalValue
			});	
			console.log("Types:", {
			    match_id: typeof parseInt(chatState.currentMatchId),
			    sender_id: typeof parseInt(currentUser.uid),
			    message_text: typeof originalValue
			});
			try {
				if (isAIChat) {
					// Handle AI chat - KEINE Erfolgsmeldung
					sendAIMessage(originalValue);
				} else {
					// Handle real user chat
					const response = await fetch('/.netlify/functions/send_message', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							match_id: parseInt(chatState.currentMatchId),
							sender_id: parseInt(currentUser.uid),
							message_text: originalValue
						})
					});

					const result = await response.json();
					
					if (response.ok && result.success) {
						// Reset AI suggestions flag so they can load on partner's response
						chatState.aiSuggestionsLoaded = false;
						// ‚ùå ENTFERNT: showNotification('Nachricht gesendet!', 'success');
						
						// Force reload messages to ensure synchronization
						setTimeout(() => loadMessages(), 100);
					} else {
						console.error('Server error:', result);
						showNotification('Nachricht konnte nicht gesendet werden: ' + (result.error || 'Unbekannter Fehler'), 'error');
						chatMessages.removeChild(messageElement);
						messageInput.value = originalValue;
					}
				}
			} catch (error) {
				console.error('Network error:', error);
				showNotification('Verbindungsfehler beim Senden', 'error');
				chatMessages.removeChild(messageElement);
				messageInput.value = originalValue;
			} finally {
				messageInput.disabled = false;
				messageInput.focus();
			}
		}


		function setupMessageInput() {
			const messageInput = document.getElementById('messageInput');
			if (messageInput) {
				// Remove any existing event listeners
				messageInput.replaceWith(messageInput.cloneNode(true));
				const newInput = document.getElementById('messageInput');
				
				newInput.addEventListener('keydown', (e) => {
					if (e.key === 'Enter') {
						e.preventDefault();
						sendMessage();
					}
				});
				newInput.focus();
			}
		}
		
		async function reportChat(match) {
			// Wenn kein Match √ºbergeben wird, automatisch das aktuelle Profil nehmen
			// F√ºr AI-Matches z.B. das gerade angezeigte Profil im Swipe
			match = match || currentProfiles?.[currentIndex] || chatState.currentMatch;

			// AI-Match: nur Illusion, kein Zugriff auf IDs n√∂tig
			if (match?.isAI) {
				if (!confirm('Sind Sie sicher, dass Sie diesen Chat melden m√∂chten?')) return;
				alert('Chat mit AI gemeldet. Vielen Dank f√ºr Ihr Feedback.');
				closeChat();
				return;
			}

			// Echte Matches pr√ºfen
			if (!match?.match_id || !currentUser?.uid) {
				alert('Fehler: Chat oder Benutzer nicht identifiziert.');
				return;
			}

			if (!confirm('Sind Sie sicher, dass Sie diesen Chat melden m√∂chten?')) return;

			try {
				const response = await fetch('/.netlify/functions/report_chat', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						match_id: parseInt(match.match_id),
						reporter_id: currentUser.uid
					}),
				});

				const result = await response.json();
				if (response.ok && result.success) {
					alert('Chat erfolgreich gemeldet. Vielen Dank f√ºr Ihr Feedback.');
					closeChat();
				} else {
					alert('Fehler beim Melden des Chats: ' + (result.error || 'Unbekannter Fehler.'));
				}
			} catch (error) {
				console.error('‚ùå Error reporting chat:', error);
				alert('Ein Netzwerkfehler ist aufgetreten.');
			}
		}



		async function updateSuggestions() {
			if (!chatState.currentMatchId || !currentUser) {
				document.getElementById('aiSuggestionsContainer').classList.add('hidden');
				return;
			}

			const mainContainer = document.getElementById('aiSuggestionsContainer');
			const thinkingBubble = document.getElementById('aiThinkingBubble');
			const typingTextElement = document.getElementById('typingText');

			// Check if this is an AI chat - if so, don't show suggestions
			const isAIChat = typeof chatState.currentMatchId === 'string' && chatState.currentMatchId.toString().includes('ai_match_');
			if (isAIChat) {
				mainContainer.classList.add('hidden');
				return;
			}

			// Only show suggestions for real user chats
			mainContainer.classList.remove('hidden');
			thinkingBubble.classList.remove('hidden');
			typingTextElement.textContent = 'One-KI denkt nach...';
			
			// Remove old suggestion buttons
			const oldButtons = mainContainer.querySelectorAll('button');
			oldButtons.forEach(button => button.remove());

			try {
				// Make sure matchId is a number for real chats
				const matchId = parseInt(chatState.currentMatchId);
				if (isNaN(matchId)) {
					console.error('‚ùå Invalid match ID for suggestions:', chatState.currentMatchId);
					mainContainer.classList.add('hidden');
					return;
				}

				const response = await fetch('/.netlify/functions/get_chat_suggestions', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ 
						matchId: matchId,  // Send as number
						currentUserId: currentUser.uid 
					}),
				});

				const result = await response.json();
				
				// Animation timeout
				setTimeout(() => {
					thinkingBubble.classList.add('hidden');

					if (result.success && result.suggestions.length > 0) {
						result.suggestions.forEach(suggestion => {
							const button = document.createElement('button');
							button.onclick = () => {
								document.getElementById('messageInput').value = suggestion;
								logSuggestionClick(suggestion);
							};

							const innerDiv = document.createElement('div');
							innerDiv.className = 'ki-beta-container';
							
							const innerSpan = document.createElement('span');
							innerSpan.className = 'ki-beta-branding';
							innerSpan.textContent = suggestion;

							innerDiv.appendChild(innerSpan);
							button.appendChild(innerDiv);
							mainContainer.appendChild(button);
						});
					} else {
						mainContainer.classList.add('hidden');
					}
				}, 2500);

			} catch (error) {
				console.error('‚ùå Error loading AI suggestions:', error);
				thinkingBubble.classList.add('hidden');
				mainContainer.classList.add('hidden');
			}
		}

		
		async function logSuggestionClick(suggestionText) {
			try {
				await fetch('/.netlify/functions/log_suggestion_click', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						userId: currentUser.uid,
						clickedSuggestion: suggestionText
					}),
				});
			} catch (error) {
				console.error('‚ùå Error logging suggestion click:', error);
			}
		}
		
		async function openMatchChat(matchId, matchUserId, matchName, matchImage) {
		  console.log('üî• Opening chat - Match ID:', matchId, 'User ID:', matchUserId);
		  closeChat();
		  
		  if (!matchId || matchUserId === undefined || !matchName) {
			console.error('‚ùå Missing required chat parameters');
			showNotification('‚ùå Fehlerhafte Chat-Daten', 'error');
			return;
		  }
		  
		  // Determine if this is an AI chat based on matchUserId being 0
		  const isAIChat = Number(matchUserId) === 0;
		  
		  // Ensure matchId is a number for database operations
		  const numericMatchId = parseInt(matchId);
		  if (isNaN(numericMatchId) || numericMatchId <= 0) {
			console.error('‚ùå Invalid match ID:', matchId);
			showNotification('‚ùå Fehlerhafte Match-ID', 'error');
			return;
		  }
		  
		  chatState = {
			currentMatchId: numericMatchId,          // Always use numeric match ID
			currentConversationId: numericMatchId,   // Always use numeric match ID
			aiSuggestionsLoaded: false,
			lastLoadedMessageCount: 0,
			messageInterval: null,
			isAI: isAIChat                           // Flag to identify AI chats
		  };

			// Chat Modal erzeugen...
			const chatModalHtml = `
				<div class="fixed inset-0 bg-black bg-opacity-50 z-[2001] flex items-center justify-center p-4" data-chat-modal>
					<div class="bg-white rounded-2xl max-w-md w-full h-[90vh] flex flex-col" onclick="event.stopPropagation()">
						<div class="bg-gray-100 p-4 flex items-center rounded-t-2xl shadow-sm">
							<img src="${matchImage || '/default-avatar.png'}" alt="${matchName}" class="w-10 h-10 rounded-full mr-3">
							<h3 class="text-lg font-bold flex-grow">${matchName}</h3>
							<div class="flex items-center space-x-2">
								${isAIChat ? `<div class="ki-beta-container relative overflow-hidden mr-2"><span class="ki-beta-branding">One-KI Beta</span></div>` : ''}
								<button onclick="reportChat()" class="text-gray-500 hover:text-red-500">
									<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
								</button>
								<button onclick="closeChat()" class="text-gray-500 hover:text-gray-700">
									<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
								</button>
							</div>
						</div>
						<div id="chatMessages" class="flex-grow p-4 overflow-y-auto space-y-2"></div>
						<div id="aiSuggestionsContainer" class="p-2 flex flex-wrap gap-2 justify-center border-t border-gray-200 hidden">
							<div id="aiThinkingBubble" class="ki-beta-container hidden">
								<span id="typingText" class="ki-beta-branding typing-animation"></span>
							</div>
						</div>
						<div class="p-4 bg-gray-100 rounded-b-2xl flex items-center">
							<input type="text" id="messageInput" placeholder="Nachricht senden..." class="flex-grow rounded-full py-2 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500" maxlength="500">
							<button onclick="sendMessage()" class="bg-blue-500 text-white rounded-full p-2 ml-2 hover:bg-blue-600">
								<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
							</button>
						</div>
					</div>
				</div>
			`;
			const chatDiv = document.createElement('div');
			chatDiv.innerHTML = chatModalHtml;
			document.body.appendChild(chatDiv);

			setupMessageInput();
			markMessagesAsRead(matchId);

			if (isAIChat) {
				loadAIMessages();
			} else {
				loadMessages();
				chatState.messageInterval = setInterval(loadMessages, 3000);
			}
		}
		
		function loadAIMessages() {
			const container = document.getElementById('chatMessages');
			if (!container || !chatState.currentMatchId) return;

			let aiMessages = JSON.parse(localStorage.getItem(`ai_chat_${chatState.currentMatchId}`) || '[]');
			container.innerHTML = '';

			if (aiMessages.length === 0) {
				container.innerHTML = `<div class="text-center text-gray-500 py-8">
					<div class="text-4xl mb-2">üëã</div>
					<p>Schreibt euch eure erste Nachricht!</p>
				</div>`;
				return;
			}

			aiMessages.forEach(msg => {
				const messageClass = msg.sender === 'user' ? 'sent' : 'received';
				const bubble = document.createElement('div');
				bubble.classList.add('message', messageClass);
				const timestamp = new Date(msg.timestamp).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
				bubble.innerHTML = `<div class="message-bubble">${escapeHtml(msg.text)}</div><div class="text-xs opacity-50 mt-1">${timestamp}</div>`;
				container.appendChild(bubble);
			});

			container.scrollTop = container.scrollHeight;
		}

		async function saveAIMessage(sender, text) {
		  const matchId = chatState.currentMatchId; // This is now the real database match ID
		  
		  if (!matchId) {
			console.warn('Keine Match-ID gefunden');
			return;
		  }
		  
		  // Store in localStorage using the real match ID
		  let aiMessages = JSON.parse(localStorage.getItem(`ai_chat_${matchId}`) || '[]');
		  aiMessages.push({
			sender: sender,
			text: text,
			timestamp: new Date().toISOString()
		  });
		  localStorage.setItem(`ai_chat_${matchId}`, JSON.stringify(aiMessages));
		  
		  // Store in database using the real match ID
		  const dbSenderId = sender === 'user' ? parseInt(currentUser.uid) : 0;
		  
		  try {
			await fetch('/.netlify/functions/send_message', {
			  method: 'POST',
			  headers: { 'Content-Type': 'application/json' },
			  body: JSON.stringify({
				match_id: matchId,        // Real database match ID
				sender_id: dbSenderId,    // 0 for AI, real user ID for user
				message_text: text,
				is_ai: sender === 'ai'
			  })
			});
		  } catch (err) {
			console.error('‚ùå Fehler beim Speichern der AI-Nachricht in DB', err);
		  }
		}

		async function sendAIMessage(messageText) {
		    console.log("sendAIMessage called with:", messageText);
			console.log("chatState.currentMatchId:", chatState.currentMatchId);
			if (!chatState.currentMatchId || !messageText) return;

			await saveAIMessage('user', messageText); // speichert lokal + DB
			loadAIMessages();

			const convId = chatState.currentMatchId;
			if (!window.aiReplyTimers) window.aiReplyTimers = {};
			if (!window.aiReplyTimers[convId]) window.aiReplyTimers[convId] = { pendingUserMessages: [] };
			window.aiReplyTimers[convId].pendingUserMessages.push({ text: messageText, ts: Date.now() });

			const delay = Math.floor(Math.random() * (60_000 - 8_000)) + 8_000; // 8‚Äì60 Sek
			window.aiReplyTimers[convId].dueAt = Date.now() + delay;
			window.aiReplyTimers[convId].id = setTimeout(() => triggerAiReply(convId), delay);

			console.log(`‚è±Ô∏è [${convId}] AI antwortet in ${Math.round(delay / 1000)}s`);
		}

		console.log('currentMatchId:', chatState.currentMatchId);
		const localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
		console.log('localMatches:', localMatches);
	
	async function triggerAiReply(convId) {
			const t = window.aiReplyTimers[convId];
			if (!t) return;

			const combinedUserText = (t.pendingUserMessages || []).map(m => m.text).join("\n");
			t.pendingUserMessages = [];

			try {
				// KORRIGIERT: Hole AI-Profile-ID aus localStorage
				const localMatches = JSON.parse(localStorage.getItem('userMatches') || '[]');
				const currentMatch = localMatches.find(m => m.match_id === convId);
				const aiProfileId = currentMatch?.ai_profile_id || 1; // Fallback auf AI-ID 1

				const response = await fetch('/.netlify/functions/ai-chat', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						aiProfileId,
						userMessage: combinedUserText,
						userProfile: {
							id: currentUser?.uid || "guest",
							name: currentUser?.email || null,
							interests: currentProfile?.interests || []
						},
						conversationId: convId
					})
				});
				
				const result = await response.json();
				const aiText = result.success ? result.response : "Entschuldige, gerade nicht verf√ºgbar.";

				// Speichern + Laden
				await saveAIMessage('ai', aiText);
				if (chatState.currentMatchId === convId) loadAIMessages();

			} catch (err) {
				console.error('AI reply failed', err);
				await saveAIMessage('ai', "Ups, da ist etwas schiefgelaufen!");
				if (chatState.currentMatchId === convId) loadAIMessages();
			} finally {
				if (window.aiReplyTimers[convId]?.id) clearTimeout(window.aiReplyTimers[convId].id);
				delete window.aiReplyTimers[convId];
			}
		}
						
